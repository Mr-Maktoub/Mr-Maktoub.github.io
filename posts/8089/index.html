<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python&amp;机器学习工具 | 马克图布</title><meta name="author" content="马克图布"><meta name="copyright" content="马克图布"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="python包下__init__.py的作用假如包名为buffer，下面有三个py文件和一个__init__.py文件 12345buffer———— __init__.py———— offpolicy_buffer.py———— onpolicy_buffer.py———— vector_onpolicy_buffer.py 一、在__init__.py里面加一些导包语句，就可以直接通过buff">
<meta property="og:type" content="article">
<meta property="og:title" content="Python&amp;机器学习工具">
<meta property="og:url" content="https://mr-maktoub.github.io/posts/8089/index.html">
<meta property="og:site_name" content="马克图布">
<meta property="og:description" content="python包下__init__.py的作用假如包名为buffer，下面有三个py文件和一个__init__.py文件 12345buffer———— __init__.py———— offpolicy_buffer.py———— onpolicy_buffer.py———— vector_onpolicy_buffer.py 一、在__init__.py里面加一些导包语句，就可以直接通过buff">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mr-maktoub.github.io/img/avatar1.png">
<meta property="article:published_time" content="2023-06-01T07:29:35.772Z">
<meta property="article:modified_time" content="2023-05-30T03:01:23.551Z">
<meta property="article:author" content="马克图布">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mr-maktoub.github.io/img/avatar1.png"><link rel="shortcut icon" href="/img/log3.jfif"><link rel="canonical" href="https://mr-maktoub.github.io/posts/8089/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python&机器学习工具',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-05-30 11:01:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/messageboard/"><i class="fa-fw iconfont icon-liaotian-04"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li><li><a class="site-page child" href="/share/"><i class="fa-fw iconfont icon-fenxiang"></i><span> 分享</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 相册</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw iconfont icon-shuji"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/FilmAndTV/"><i class="fa-fw iconfont icon-yingshi1"></i><span> 影视</span></a></li><li><a class="site-page child" href="/daohang/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="马克图布"><img class="site-icon" src="/img/log3.jfif"/><span class="site-name">马克图布</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/messageboard/"><i class="fa-fw iconfont icon-liaotian-04"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li><li><a class="site-page child" href="/share/"><i class="fa-fw iconfont icon-fenxiang"></i><span> 分享</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 相册</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw iconfont icon-shuji"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/FilmAndTV/"><i class="fa-fw iconfont icon-yingshi1"></i><span> 影视</span></a></li><li><a class="site-page child" href="/daohang/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python&amp;机器学习工具</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-01T07:29:35.772Z" title="发表于 2023-06-01 15:29:35">2023-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-30T03:01:23.551Z" title="更新于 2023-05-30 11:01:23">2023-05-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python&amp;机器学习工具"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><h3 id="包下-init-py的作用"><a href="#包下-init-py的作用" class="headerlink" title="包下__init__.py的作用"></a>包下<code>__init__.py</code>的作用</h3><p>假如包名为<code>buffer</code>，下面有三个<code>py</code>文件和一个<code>__init__.py</code>文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer</span><br><span class="line">———— __init__.py</span><br><span class="line">———— offpolicy_buffer.py</span><br><span class="line">———— onpolicy_buffer.py</span><br><span class="line">———— vector_onpolicy_buffer.py</span><br></pre></td></tr></table></figure>
<p>一、在<code>__init__.py</code>里面加一些导包语句，就可以直接通过buffer 导入一些其包中<code>py</code>文件里面的一些类。</p>
<p>eg.</p>
<p><code>__init__.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""Implementation of Buffer."""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> buffer.base <span class="keyword">import</span> BaseBuffer</span><br><span class="line"><span class="keyword">from</span> buffer.offpolicy_buffer <span class="keyword">import</span> OffPolicyBuffer</span><br><span class="line"><span class="keyword">from</span> buffer.onpolicy_buffer <span class="keyword">import</span> OnPolicyBuffer</span><br><span class="line"><span class="keyword">from</span> buffer.vector_offpolicy_buffer <span class="keyword">import</span> VectorOffPolicyBuffer</span><br><span class="line"><span class="keyword">from</span> buffer.vector_onpolicy_buffer <span class="keyword">import</span> VectorOnPolicyBuffer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__all__ = [</span><br><span class="line">    <span class="string">'BaseBuffer'</span>,</span><br><span class="line">    <span class="string">'OffPolicyBuffer'</span>,</span><br><span class="line">    <span class="string">'OnPolicyBuffer'</span>,</span><br><span class="line">    <span class="string">'VectorOffPolicyBuffer'</span>,</span><br><span class="line">    <span class="string">'VectorOnPolicyBuffer'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码是Python中一个包（package）的初始化文件 <code>__init__.py</code> 的内容。在这个文件中，它声明了该包下的所有模块（modules）和子包（sub-packages）的导入和暴露。</p>
<p>具体来说：</p>
<ul>
<li><code>"""Implementation of Buffer."""</code> 是对整个包的简要描述，通常会包含包的功能和用途等信息。</li>
<li><code>from buffer.base import BaseBuffer</code> 表示从 <code>buffer</code> 包中导入 <code>base</code> 模块中的 <code>BaseBuffer</code> 类。</li>
<li><code>from buffer.offpolicy_buffer import OffPolicyBuffer</code> 表示从 <code>buffer</code> 包中导入 <code>offpolicy_buffer</code> 模块中的 <code>OffPolicyBuffer</code> 类。</li>
<li><code>from buffer.onpolicy_buffer import OnPolicyBuffer</code> 表示从 <code>buffer</code> 包中导入 <code>onpolicy_buffer</code> 模块中的 <code>OnPolicyBuffer</code> 类。</li>
<li><code>from buffer.vector_offpolicy_buffer import VectorOffPolicyBuffer</code> 表示从 <code>buffer</code> 包中导入 <code>vector_offpolicy_buffer</code> 模块中的 <code>VectorOffPolicyBuffer</code> 类。</li>
<li><code>from buffer.vector_onpolicy_buffer import VectorOnPolicyBuffer</code> 表示从 <code>buffer</code> 包中导入 <code>vector_onpolicy_buffer</code> 模块中的 <code>VectorOnPolicyBuffer</code> 类。</li>
<li><code>__all__</code> 是一个特殊的变量，它是一个列表，包含了当前包下需要导出的模块和类的名称。这样，在导入该包时，可以通过 <code>from buffer import *</code> 的方式导入指定的模块和类。</li>
</ul>
<p>通过在 <code>__init__.py</code> 文件中声明模块和类的导入，可以在使用该包时直接使用 <code>buffer</code> 包下的各个模块和类，而无需在代码中逐个导入。</p>
<p>即</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> buffer <span class="keyword">import</span> VectorOnPolicyBuffer</span><br></pre></td></tr></table></figure>
<h3 id="python中的-与-用法详解"><a href="#python中的-与-用法详解" class="headerlink" title="python中的*与**用法详解"></a><code>python中的*与**用法详解</code></h3><p>python中<code>*</code>与 <code>**</code>的作用一共有四个，分别是数值计算、序列解包、函数声明的时候作为函数形参、函数调用的时候作为函数实参</p>
<p>序列(列表、元组)解包</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a,b,*c =<span class="built_in">list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'a='</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'b='</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'c='</span>,c)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a= 1</span></span><br><span class="line"><span class="string">b= 2</span></span><br><span class="line"><span class="string">c= [3, 4, 5]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">a,b,*c =<span class="built_in">list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'a='</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'b='</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'c='</span>,c)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a= 1</span></span><br><span class="line"><span class="string">b= 2</span></span><br><span class="line"><span class="string">c= []</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数声明的时候作为函数形参</p>
<p>大家应该会经常看到类似这样的函数：def function( <code>*</code> arg,<code>**</code>kwargs): ，这里的<code>*</code> arg与<code>**</code>kwarg都是为了接受不定长参数的。其中<code>*</code>arg是位置参数，用于接受不定长的无名参数，本质是一个元组，<code>**</code>kwargs是关键字参数，本质是一个字典。还有一点arg,kwargs就是一个变量名，换成 <code>*</code>a,<code>**</code>b效果是一样的。接下来看代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">    <span class="built_in">print</span>(args[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(kwargs[<span class="string">'b'</span>])</span><br><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line">my_dict = {<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">0</span>,<span class="string">'c'</span>:<span class="number">2</span>}</span><br><span class="line">function(*my_list,**my_dict)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>- *args 返回的是一个tuple元组</code><br><code>- **kwargs返回的是一个dict字典</code><br><code>- **kwargs传参只能是A=“B”形式</code><br><code>- *args必须要在kwargs前面</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'args=<span class="subst">{args}</span>'</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'kwargs=<span class="subst">{kwargs}</span>'</span>)</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,food=<span class="string">"orange"</span>,age=<span class="number">12</span>,sex=<span class="string">"F"</span>)</span><br><span class="line">dic = {<span class="string">'name'</span>:<span class="string">'lisa'</span>,<span class="string">'job'</span>:<span class="string">'nurse'</span>}</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">args=(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">kwargs={<span class="string">'food'</span>: <span class="string">'orange'</span>, <span class="string">'age'</span>: <span class="number">12</span>, <span class="string">'sex'</span>: <span class="string">'F'</span>}</span><br></pre></td></tr></table></figure>
<p><strong>实参分解</strong><br><code>即将参数拆分成单独的个体</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">data1 = (<span class="string">'hello'</span>,<span class="string">'python'</span>,<span class="string">'java'</span>)</span><br><span class="line">test(*data1)   <span class="comment"># 相当于分别传入了3个参数</span></span><br><span class="line">结果：</span><br><span class="line">a= hello</span><br><span class="line">b= python</span><br><span class="line">c= java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时字典data2的key值必须和形参名称相等，顺序可以不一样</span></span><br><span class="line">data2 = {<span class="string">'b'</span>:<span class="string">'lisa'</span>,<span class="string">'c'</span>:<span class="number">12</span>,<span class="string">'a'</span>:<span class="string">'F'</span>}</span><br><span class="line">test(**data2)</span><br><span class="line">结果：</span><br><span class="line">a= F</span><br><span class="line">b= lisa</span><br><span class="line">c= <span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a><strong>IPython</strong></h3><p><code>from IPython import display</code></p>
<p>The <code>IPython.display</code> module provides a set of functions that can be used to display various types of output in Jupyter notebooks, including images, audio, video, HTML, Markdown, and more.</p>
<p>The <code>display</code> function from the <code>IPython.display</code> module is a particularly useful function, as it allows you to display arbitrary Python expressions in the notebook, and it automatically chooses the appropriate display mechanism based on the type of the expression. For example, you can use <code>display</code> to display the value of a variable, the output of a function call, or even a plot generated by a visualization library.</p>
<p>Here’s an example of how you can use <code>display</code> to show an image in a Jupyter notebook:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display, Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the image from a file</span></span><br><span class="line">image = Image(filename=<span class="string">'my_image.png'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display the image in the notebook</span></span><br><span class="line">display(image)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>In this example, we first import both the <code>display</code> and <code>Image</code> functions from the <code>IPython.display</code> module. We then load an image from a file using the <code>Image</code> function, and finally we use the <code>display</code> function to show the image in the notebook.</p>
<p>Overall, the <code>IPython.display</code> module and the <code>display</code> function are essential tools for working with Jupyter notebooks, as they make it easy to display a wide variety of output formats directly in the notebook.</p>
<h3 id="pylab"><a href="#pylab" class="headerlink" title="pylab"></a><strong>pylab</strong></h3><p><code>pylab</code> and <code>IPython</code> are two different things in the Python ecosystem.</p>
<p><code>pylab</code> is a module in the matplotlib library that provides a convenient interface for creating plots and charts in Python. It is essentially a convenience module that provides a simple way to access all of the functionality of <code>matplotlib</code> and <code>numpy</code> in a single namespace. By importing <code>pylab</code>, you get access to a wide range of functionality for creating plots and visualizations, including line plots, scatter plots, histograms, and more.</p>
<p>Here’s an example of how you can use <code>pylab</code> to create a simple line plot:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pylab</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create some data</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a line plot</span></span><br><span class="line">pylab.plot(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the plot</span></span><br><span class="line">pylab.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>IPython</strong></p>
<p>On the other hand, <code>IPython</code> is a powerful interactive shell for Python that provides a rich set of tools and features for working with code in an interactive and exploratory way. It is particularly well-suited for working with Jupyter notebooks, which allow you to mix code, text, and visualizations in a single document.</p>
<p><code>IPython</code> provides a range of useful features for working with Python code interactively, including tab completion, object introspection, and interactive debugging. It also provides a range of useful tools for working with Jupyter notebooks, including support for displaying rich media content (such as images, audio, and video), integrating with third-party libraries, and sharing notebooks with others.</p>
<p>Overall, both <code>pylab</code> and <code>IPython</code> are useful tools for working with Python code, but they serve different purposes. <code>pylab</code> is primarily focused on creating visualizations, while <code>IPython</code> is focused on providing an interactive environment for working with Python code.</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>Python内置的<code>filter()</code>函数能够从可迭代对象（如字典、列表）中筛选某些元素，并生成一个新的迭代器。可迭代对象是一个可以被“遍历”的Python对象，也就是说，它将按顺序返回各元素，这样我们就可以在<code>fo</code>r循环中使用它。</p>
<p><code>filter()</code>函数的基本语法是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function, iterable)</span><br></pre></td></tr></table></figure>
<p>一个可迭代的filter对象，可以使用<code>list()</code>函数将其转化为列表，这个列表包含过滤器对象中返回的所有的项。</p>
<p><code>filter()</code>函数所提供的过滤方法，通常比用列表解析更有效，特别是当我们处理更大的数据集时。例如，列表解析会生成一个新列表，这会增加该处理的运行时间。当列表解析执行完毕它的表达式后，内存中会有两个列表。但是，<code>filter()</code>将生成一个简单的对象，该对象包含对原始列表的引用、提供的函数以及原始列表中位置的索引，这样操作占用的内存更少。</p>
<p><code>filter()</code>的第一个参数是一个函数，用它来决定第二个参数所引用的可迭代对象中的每一项的去留。此函数被调用后，当返回<code>False</code>时，第二个参数中的可迭代对象里面相应的值就会被删除。针对这个函数，可以是一个普通函数，也可以使用<code>lambda</code>函数，特别是当表达式不那么复杂的时候。</p>
<p>下面是<code>filter()</code>中使用<code>lambda</code>函数的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(<span class="keyword">lambda</span> item: item[] expression, iterable)</span><br></pre></td></tr></table></figure>
<p>将下面的列表，用于<code>lambda</code>函数，根据<code>lambda</code>函数表达式筛选列表中的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">creature_names = [<span class="string">'Sammy'</span>, <span class="string">'Ashley'</span>, <span class="string">'Jo'</span>, <span class="string">'Olly'</span>, <span class="string">'Jackie'</span>, <span class="string">'Charlie'</span>]</span><br></pre></td></tr></table></figure>
<p>要筛选此列表以元音开头的水族馆生物的名称，<code>lambda</code>函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x[<span class="number">0</span>].lower() <span class="keyword">in</span> <span class="string">'aeiou'</span>, creature_names)))</span><br></pre></td></tr></table></figure>
<p>在这里，我们将列表中的一个项声明为<code>x</code>，并以<code>x[0]</code>的方式访问每个字符串的第一个字符，并且要将字母转化为小写，以确保将字母与<code>'aeiou'</code>中的字符匹配。</p>
<p>最后，要提供可迭代对向<code>creature_name</code>。与上一节一样，用<code>list()</code>将返回结果转化为列表表。</p>
<p>输出如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[<span class="string">'Ashley'</span>, <span class="string">'Olly'</span>]</span></span><br></pre></td></tr></table></figure>
<p>当然，写一个函数，也能够实现类似的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">creature_names = [<span class="string">'Sammy'</span>, <span class="string">'Ashley'</span>, <span class="string">'Jo'</span>, <span class="string">'Olly'</span>, <span class="string">'Jackie'</span>, <span class="string">'Charlie'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">names_vowels</span>(<span class="params">x</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>].lower() <span class="keyword">in</span> <span class="string">'aeiou'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filtered_names = <span class="built_in">filter</span>(names_vowels, creature_names)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(filtered_names))</span><br></pre></td></tr></table></figure>
<p>在<code>names_vowels</code>函数中用一个表达式，完成了对<code>creature_names</code>的过滤。</p>
<p>同样，输出如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[<span class="string">'Ashley'</span>, <span class="string">'Olly'</span>]</span></span><br></pre></td></tr></table></figure>
<p>总的来说，在<code>filter()</code>函数中使用lambda函数得到的结果与使用常规函数得到的结果相同。如果所要过滤数据更复杂了，还可能要使用正则表达式，这可能会提高代码的可读性。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>map是python内置函数，会根据提供的函数对指定的序列做映射。格式是<code>map(function,iterable,...)</code><br>第一个参数接受一个函数名，后面的参数接受一个或多个可迭代的序列，返回的是一个集合。</p>
<p>把函数依次作用在list中的每一个元素上，得到一个新的list并返回。注意，map不改变原list，而是返回一个新list。<br>比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> square(x):</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">map</span>(square,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 结果如下:</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p>还可以实现类型转换 ,比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="built_in">int</span>,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#字符串转list</span></span><br><span class="line"><span class="built_in">map</span>(<span class="built_in">int</span>,<span class="string">'1234'</span>)</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h4 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h4><p> Python 中的 reduce() 函数，它可以用于处理列表。</p>
<p>Python 提供了一个名为 reduce() 的函数，可以更加简洁地实现累积运算。reduce() 函数的语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(fn,<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p>reduce() 函数从左至右依次累计使用列表中的元素调用 fn 函数，从而将列表累积生成单个值。</p>
<p>与 map() 和 filter() 函数不同，reduce() 不是 Python 内置函数。实际上，reduce() 函数来自 functools 模块。如果想要使用 reduce() 函数，我们需要在代码开始时使用以下语句导入 functools 模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br></pre></td></tr></table></figure>
<p>比如 <code>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</code>， 就是计算<code>((((1+2)+3)+4)+5)</code> .</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reduce(<span class="built_in">min</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,])</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">reduce(<span class="built_in">max</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,])</span><br><span class="line"><span class="comment"># 6</span></span><br></pre></td></tr></table></figure>
<h3 id="Python中的Class"><a href="#Python中的Class" class="headerlink" title="Python中的Class"></a>Python中的Class</h3><h4 id="staticmethod"><a href="#staticmethod" class="headerlink" title="@staticmethod"></a>@staticmethod</h4><p>@staticmethod是一个Python中的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=装饰器&amp;spm=1001.2101.3001.7020">装饰器</a>（decorator），用于标记一个静态方法。</p>
<p>静态方法是一种在类中定义的方法，它与实例无关，因此可以在不创建类实例的情况下调用。与普通方法不同，静态方法没有self参数，因此它不能访问实例属性和方法。</p>
<p>在Python中，使用@staticmethod装饰器可以将一个方法转换为静态方法，即使该方法定义在类中。使用静态方法的主要优点是可以在不创建类实例的情况下调用该方法，从而提高代码的灵活性和可重用性。</p>
<p>下面是一个使用@staticmethod装饰器定义静态方法的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_static_method</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述示例中，my_static_method方法被@staticmethod装饰器标记为静态方法。因此，可以通过以下方式直接调用该方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = MyClass.my_static_method(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>在调用静态方法时，不需要创建类实例，直接使用类名即可。静态方法可以通过类或类实例来调用，但不可以通过实例访问静态方法。</p>
<p>staticmethod相当于定义了一个局部域函数为该类专门服务</p>
<h4 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h4><p><code>@property</code> 是一个装饰器（decorator）在 Python 中的使用。它提供了一种便捷的方式来定义类的属性，并允许对属性进行访问和修改的控制。</p>
<p>使用 <code>@property</code> 装饰器可以将一个方法转换为类的只读属性，它的特点是在访问该属性时，会自动调用对应的方法。下面是一个示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        self._radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * self._radius * self._radius</span><br><span class="line"></span><br><span class="line">circle = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(circle.radius)  <span class="comment"># 输出：5</span></span><br><span class="line"><span class="built_in">print</span>(circle.area)    <span class="comment"># 输出：78.5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>@property</code> 装饰器被应用到 <code>radius</code> 和 <code>area</code> 方法上。当我们访问 <code>circle.radius</code> 和 <code>circle.area</code> 时，实际上会自动调用 <code>radius()</code> 和 <code>area()</code> 方法，并返回对应的值。</p>
<p><code>@property</code> 装饰器还提供了一种控制属性访问和修改的方法。我们可以通过定义另外的装饰器来实现属性的写入控制，例如 <code>@radius.setter</code>，它可以设置属性的新值。下面是一个示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        self._radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @radius.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            self._radius = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Radius must be positive."</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * self._radius * self._radius</span><br><span class="line"></span><br><span class="line">circle = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(circle.radius)  <span class="comment"># 输出：5</span></span><br><span class="line"></span><br><span class="line">circle.radius = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(circle.radius)  <span class="comment"># 输出：7</span></span><br><span class="line"><span class="built_in">print</span>(circle.area)    <span class="comment"># 输出：153.86</span></span><br><span class="line"></span><br><span class="line">circle.radius = -<span class="number">2</span>  <span class="comment"># 抛出 ValueError 异常 ValueError: Radius must be positive.</span></span><br><span class="line">circle.area = <span class="number">3</span> <span class="comment"># 只读。 AttributeError: can't set attribute</span></span><br></pre></td></tr></table></figure>
<h4 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a><code>__getitem__</code></h4><p><code>__getitem__</code> 是 Python 中的特殊方法（special method），用于实现对象的索引访问操作。当我们使用索引运算符 <code>[]</code> 访问对象的元素时，Python 会调用对象的 <code>__getitem__</code> 方法来执行相应的操作。</p>
<p>下面是一个示例，展示了如何在自定义类中使用 <code>__getitem__</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items</span>):</span><br><span class="line">        self.items = items</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items[index]</span><br><span class="line"></span><br><span class="line">my_list = MyList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])  <span class="comment"># 输出：1</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">2</span>])  <span class="comment"># 输出：3</span></span><br><span class="line"><span class="built_in">print</span>(my_list[-<span class="number">1</span>])  <span class="comment"># 输出：5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>MyList</code> 类定义了 <code>__getitem__</code> 方法，并在该方法内部直接使用了索引访问 <code>self.items</code> 的元素。当我们使用 <code>my_list[index]</code> 的形式进行索引访问时，Python 会自动调用 <code>__getitem__</code> 方法，并返回相应的结果。</p>
<p><code>__getitem__</code> 方法还可以处理切片操作。下面是一个处理切片的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items</span>):</span><br><span class="line">        self.items = items</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(index, <span class="built_in">slice</span>):</span><br><span class="line">            <span class="keyword">return</span> self.items[index.start:index.stop:index.step]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.items[index]</span><br><span class="line"></span><br><span class="line">my_list = MyList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># 输出：[2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(my_list[::<span class="number">2</span>])  <span class="comment"># 输出：[1, 3, 5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>__getitem__</code> 方法检查索引是否是一个切片对象。如果是切片，就返回切片范围内的元素；如果不是切片，就返回单个索引对应的元素。</p>
<p>通过实现 <code>__getitem__</code> 方法，我们可以使自定义类的实例具备索引访问的功能，就像列表或其他可索引的对象一样。这样可以提高代码的灵活性和可读性。</p>
<h4 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h4><p>在 Python 中，<code>__call__</code> 是一个特殊方法（special method），用于使对象像函数一样被调用。</p>
<p>当一个类定义了 <code>__call__</code> 方法时，该类的实例对象可以被直接调用，就像调用函数一样。这意味着可以像调用函数一样对该对象进行操作，而不仅仅是通过方法调用。</p>
<p>以下是一个简单的示例，演示了如何使用 <code>__call__</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Called with arguments:"</span>, args)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Called with keyword arguments:"</span>, kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Example 类的实例对象</span></span><br><span class="line">obj = Example()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用实例对象进行调用</span></span><br><span class="line">obj(<span class="number">1</span>, <span class="number">2</span>, a=<span class="number">3</span>, b=<span class="number">4</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Called <span class="keyword">with</span> arguments: (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Called <span class="keyword">with</span> keyword arguments: {<span class="string">'a'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">4</span>}</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>Example</code> 类定义了 <code>__call__</code> 方法。当创建 <code>Example</code> 的实例对象 <code>obj</code> 后，可以像调用函数一样使用 <code>obj</code> 进行调用。在调用时，传递的参数和关键字参数都会传递给 <code>__call__</code> 方法，并进行相应的操作。</p>
<p><code>__call__</code> 方法提供了一种使对象可调用的方式，这在某些情况下可以带来便利。例如，当想要实现一个可调用的对象，而不是定义一个独立的函数时，可以使用 <code>__call__</code> 方法来实现这种行为。</p>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>简单用法——隐式函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var = <span class="keyword">lambda</span> a,b : (a + <span class="number">20</span>) * b</span><br><span class="line">var(<span class="number">20</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 80</span></span><br><span class="line">var = <span class="keyword">lambda</span> *a:  [i + <span class="number">20</span> <span class="keyword">for</span> i <span class="keyword">in</span> a]</span><br><span class="line">var(<span class="number">30</span>,<span class="number">39</span>)</span><br><span class="line">[<span class="number">50</span>, <span class="number">59</span>]</span><br></pre></td></tr></table></figure>
<p>匿名函数lambda：是指一类无需定义标识符（函数名）的函数或子程序。所谓匿名函数，通俗地说就是没有名字的函数，lambda函数<strong>没有名字</strong>，是一种<strong>简单的</strong>、<strong>在同一行中定义函数</strong>的方法。</p>
<p>lambda函数一般功能简单：单行expression决定了lambda函数不可能完成复杂的逻辑，只能完成非常简单的功能。由于其实现的功能一目了然，甚至不需要专门的名字来说明。</p>
<p>lambda 函数可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值。</p>
<p><strong>lambda表达式</strong>只允许<strong>包含一个表达式</strong>，不能包含复杂语句，该<strong>表达式的运算结果</strong>就是<strong>函数的返回值</strong>。</p>
<p>lambda函数实际生成了一个lambda对象。</p>
<p>lambda表达式的基本语法如下：</p>
<p>lambda arg1,arg2,arg3… :&lt;表达式&gt;</p>
<p>arg1/arg2/arg3为函数的<strong>参数（函数输入）</strong>，表达式相当于<strong>函数体</strong>，运算结果是表达式的运算结果。</p>
<p>例如：</p>
<p>lambda x, y: x<em>y；函数输入是x和y，输出是它们的积x</em>y</p>
<p>lambda:None；函数没有输入参数，输出是None</p>
<p>lambda *args: sum(args); 输入是任意个数的参数，输出是它们的和(隐性要求是输入参数必须能够进行加法运算)</p>
<p>lambda **kwargs: 1；输入是任意键值对参数，输出是1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#测试lambda函数</span><br><span class="line">f=lambda a,b,c,d:a*b*c*d</span><br><span class="line">print(f(1,2,3,4))  #相当于下面这个函数</span><br><span class="line">def test01(a,b,c,d):</span><br><span class="line">    return a*b*c*d</span><br><span class="line">print(test01(1,2,3,4))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g=[lambda a:a*2,lambda b:b*3]</span><br><span class="line">print(g[0](5))  #调用</span><br><span class="line">print(g[1](6))</span><br></pre></td></tr></table></figure>
<p>由于lambda语法是固定的，其本质上只有一种用法，那就是定义一个lambda函数。在实际中，根据这个lambda函数应用场景的不同，可以将lambda函数的用法扩展为以下几种：</p>
<p><strong>1.将lambda函数赋值给一个变量，通过这个变量间接调用该lambda函数。</strong></p>
<p>例如，执行语句add=lambda x, y: x+y，定义了加法函数lambda x, y: x+y，并将其赋值给变量add，这样变量add便成为具有加法功能的函数。例如，执行add(1,2)，输出为3。</p>
<p><strong>2.将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换。</strong></p>
<p>例如，为了把标准库time中的函数sleep的功能屏蔽(Mock)，我们可以在程序初始化时调用：time.sleep=lambda x:None。这样，在后续代码中调用time库的sleep函数将不会执行原有的功能。例如，执行time.sleep(3)时，程序不会休眠3秒钟，而是什么都不做。</p>
<p><strong>3.将lambda函数作为参数传递给其他函数。</strong></p>
<p>函数的返回值也可以是函数。例如return lambda x, y: x+y返回一个加法函数。这时，lambda函数实际上是定义在某个函数内部的函数，称之为嵌套函数，或者内部函数。对应的，将包含嵌套函数的函数称之为外部函数。内部函数能够访问外部函数的局部变量，这个特性是闭包(Closure)编程的基础，在这里我们不展开。</p>
<p><strong>部分Python内置函数接受函数作为参数</strong>,典型的<strong>此类内置函数有</strong>这些:</p>
<p><strong>filter函数</strong> 此时lambda函数用于指定过滤列表元素的条件。例如filter(lambda x: x % 3 == 0, [1, 2, 3])指定将列表[1,2,3]中能够被3整除的元素过滤出来，其结果是[3]。</p>
<p><strong>sorted函数</strong> 此时lambda函数用于指定对列表中所有元素进行排序的准则。例如sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x))将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与5距离从小到大进行排序，其结果是[5, 4, 6, 3, 7, 2, 8, 1, 9]。</p>
<p><strong>map函数</strong> 此时lambda函数用于指定对列表中每一个元素的共同操作。例如map(lambda x: x+1, [1, 2,3])将列表[1, 2, 3]中的元素分别加1，其结果[2, 3, 4]。</p>
<p><strong>reduce函数</strong> 此时lambda函数用于指定列表中两两相邻元素的结合条件。例如reduce(lambda a, b: ‘{}, {}’.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])将列表 [1, 2, 3, 4, 5, 6, 7, 8, 9]中的元素从左往右两两以逗号分隔的字符的形式依次结合起来，其结果是’1, 2, 3, 4, 5, 6, 7, 8, 9’。</p>
<p>另外，部分Python库函数也接收函数作为参数，例如gevent的spawn函数。此时，lambda函数也能够作为参数传入。</p>
<h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p><strong>问题</strong></p>
<p>你写好了一个函数，然后想为这个函数的参数增加一些额外的信息，这样的话其他使用者就能清楚的知道这个函数应该怎么使用。</p>
<p><strong>解决方案</strong></p>
<p>使用函数参数注解是一个很好的办法，它能提示程序员应该怎样正确使用这个函数。 例如，下面有一个被注解了的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x:<span class="built_in">int</span>, y:<span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>
<p>python解释器不会对这些注解添加任何的语义。它们不会被类型检查，运行时跟没有加注解之前的效果也没有任何差距。 然而，对于那些阅读源码的人来讲就很有帮助啦。第三方工具和框架可能会对这些注解添加语义。同时它们也会出现在文档中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(add)</span><br><span class="line">Help on function add <span class="keyword">in</span> module __main__:</span><br><span class="line">add(x: <span class="built_in">int</span>, y: <span class="built_in">int</span>) -&gt; <span class="built_in">int</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>尽管你可以使用任意类型的对象给函数添加注解(例如数字，字符串，对象实例等等)，不过通常来讲使用类或者字符串会比较好点。</p>
<p>语法注意的点：</p>
<ul>
<li>变量类型：在变量名后加一个冒号，冒号后写变量的数据类型，如 int、dict 等</li>
<li>函数返回类型：方法参数中如变量类型，在参数括号后加一个箭头，箭头后返回值的类型</li>
<li>格式要求（PEP 8，非强制）：变量名和冒号无空格，冒号和后边类型间加一个空格，箭头左右均有一个空格</li>
</ul>
<p><strong>讨论</strong></p>
<p>函数注解只存储在函数的 <code>__annotations__</code> 属性中。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.__annotations__</span><br><span class="line">{<span class="string">'y'</span>: &lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt;, <span class="string">'return'</span>: &lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt;, <span class="string">'x'</span>: &lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt;}</span><br></pre></td></tr></table></figure>
<p>尽管注解的使用方法可能有很多种，但是它们的主要用途还是文档。 因为python并没有类型声明，通常来讲仅仅通过阅读源码很难知道应该传递什么样的参数给这个函数。 这时候使用注解就能给程序员更多的提示，让他们可以正确的使用函数。</p>
<p>参考9.20小节的一个更加高级的例子，演示了如何利用注解来实现多分派(比如重载函数)。</p>
<h4 id="标准库-typing-类型注解标注"><a href="#标准库-typing-类型注解标注" class="headerlink" title="标准库 typing 类型注解标注"></a>标准库 typing 类型注解标注</h4><p><a target="_blank" rel="noopener" href="https://www.gairuo.com/p/python-library-typing">参考</a></p>
<p>在<a target="_blank" rel="noopener" href="https://www.gairuo.com/p/python-type-annotations">Python 类型注解</a>中我们介绍过，通过类型注解可以提高代码的可读性和易用性，但对于复杂的数据结构就需要借助 typing 模块来表达这些数据结构。</p>
<p> typing 的作用</p>
<p><a target="_blank" rel="noopener" href="https://www.gairuo.com/p/python-type-annotations">Python 类型注解</a>是用来对变量和函数的参数返回值类型做注解（暗示），帮助开发者写出更加严谨的代码，让调用方减少类型方面的错误。</p>
<p>但是，类型注解语法传入的类型表述能力有限，不能说明复杂的类型组成情况，因此引入了 typing 模块，来实现复杂的类型表达。</p>
<p> <strong>基础用法</strong></p>
<p>以下是典型的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span>, <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line">names: <span class="type">List</span>[<span class="built_in">str</span>] = [<span class="string">'lily'</span>, <span class="string">'tom'</span>]</span><br><span class="line">version: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>)</span><br><span class="line">operations: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">bool</span>] = {<span class="string">'sad'</span>: <span class="literal">False</span>, <span class="string">'happy'</span>: <span class="literal">True</span>}</span><br></pre></td></tr></table></figure>
<p>安装 mypy 库运行脚本，会强制按类型检测，不符合类型注解要求的会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install mypy -U</span><br><span class="line"><span class="comment"># 运行脚本</span></span><br><span class="line">mypy program.py</span><br></pre></td></tr></table></figure>
<p>类型</p>
<p>这些是一些最常见的内置类型的示例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>整型 integer</td>
</tr>
<tr>
<td>float</td>
<td>浮点数字</td>
</tr>
<tr>
<td>bool</td>
<td>布尔（int 的子类）</td>
</tr>
<tr>
<td>str</td>
<td>字符 (unicode)</td>
</tr>
<tr>
<td>bytes</td>
<td>8 位字符</td>
</tr>
<tr>
<td>object</td>
<td>任意对象（公共基类）</td>
</tr>
<tr>
<td>List[str]</td>
<td>字符组成的列表</td>
</tr>
<tr>
<td>Tuple[int, int]</td>
<td>两个int对象的元组</td>
</tr>
<tr>
<td>Tuple[int, …]</td>
<td>任意数量的 int 对象的元组</td>
</tr>
<tr>
<td>Dict[str, int]</td>
<td>键是 str 值是 int 的字典</td>
</tr>
<tr>
<td>Iterable[int]</td>
<td>包含 int 的可迭代对象</td>
</tr>
<tr>
<td>Sequence[bool]</td>
<td>布尔值序列（只读）</td>
</tr>
<tr>
<td>Mapping[str, int]</td>
<td>从 str 键到 int 值的映射（只读）</td>
</tr>
<tr>
<td>Any</td>
<td>具有任意类型的动态类型值</td>
</tr>
<tr>
<td>Union</td>
<td>联合类型</td>
</tr>
<tr>
<td>Optional</td>
<td>参数可以为空或已经声明的类型</td>
</tr>
<tr>
<td>Mapping</td>
<td>映射，是 collections.abc.Mapping 的泛型</td>
</tr>
<tr>
<td>MutableMapping</td>
<td>Mapping 对象的子类，可变</td>
</tr>
<tr>
<td>Generator</td>
<td>生成器类型, Generator[YieldType、SendType、ReturnType]</td>
</tr>
<tr>
<td>NoReturn</td>
<td>函数没有返回结果</td>
</tr>
<tr>
<td>Set</td>
<td>集合 set 的泛型, 推荐用于注解返回类型</td>
</tr>
<tr>
<td>AbstractSet</td>
<td>collections.abc.Set 的泛型，推荐用于注解参数</td>
</tr>
<tr>
<td>Sequence</td>
<td>collections.abc.Sequence 的泛型，list、tuple 等的泛化类型</td>
</tr>
<tr>
<td>TypeVar</td>
<td>自定义兼容特定类型的变量</td>
</tr>
<tr>
<td>Generic</td>
<td>自定义泛型类型</td>
</tr>
<tr>
<td>NewType</td>
<td>声明一些具有特殊含义的类型</td>
</tr>
<tr>
<td>Callable</td>
<td>可调用类型, Callable[[参数类型], 返回类型]</td>
</tr>
</tbody>
</table>
</div>
<p>Any 类型和类型构造函数如 List，Dict，Iterable 和 Sequence 定义了类型模型。</p>
<p>Dict 类型是一个通用类，由 […] 中的类型参数表示。 如 Dict[int，str] 是从整数到字符串的字典，而 Dict[Any, Any] 是动态键入（任意）值和键的字典。 List 是另一个通用类。 Dict 和 List 分别是内置 dict 和 list 的别名。</p>
<p>Iterable、Sequence 和 Mapping 是与 Python 协议相对应的通用类型。 例如，当期望 Iterable[str] 或 Sequence[str] 时，str 对象或 List[str] 对象有效。 请注意，尽管它们类似于 collections.abc（以前的collections）中定义的抽象基类，但它们也不相同，因为内置的collection 类型对象不支持索引。</p>
<p>变量</p>
<p>Python 3.6 在 PEP 526 中引入了用于注释变量的语法，我们在大多数示例中都使用了它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明变量类型的类型的方式，python 3.6 +</span></span><br><span class="line">age: <span class="built_in">int</span> = <span class="number">1</span></span><br><span class="line"><span class="comment"># 在 Python 3.5 及更低版本中，您可以改用类型注释</span></span><br><span class="line"><span class="comment"># 同上效果</span></span><br><span class="line">age = <span class="number">1</span>  <span class="comment"># type: <span class="built_in">int</span></span></span><br><span class="line"><span class="comment"># 无需初始化变量即可对其进行注释</span></span><br><span class="line">a: <span class="built_in">int</span>  <span class="comment"># ok（但不能调用，name 'a' is not defined，直到被赋值）</span></span><br><span class="line"><span class="comment"># 在条件分支中很有用</span></span><br><span class="line">child: <span class="built_in">bool</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    child = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    child = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>内置类型</p>
<p>typing 内置的一些类型的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Set</span>, <span class="type">Dict</span>, <span class="type">Tuple</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于简单的 Python 内置类型，只需使用类型的名称</span></span><br><span class="line">x: <span class="built_in">int</span> = <span class="number">1</span></span><br><span class="line">x: <span class="built_in">float</span> = <span class="number">1.0</span></span><br><span class="line">x: <span class="built_in">bool</span> = <span class="literal">True</span></span><br><span class="line">x: <span class="built_in">str</span> = <span class="string">"test"</span></span><br><span class="line">x: <span class="built_in">bytes</span> = <span class="string">b"test"</span></span><br><span class="line"><span class="comment"># 对于 collections ，类型名称用大写字母表示，并且</span></span><br><span class="line"><span class="comment"># collections 内类型的名称在方括号中</span></span><br><span class="line">x: <span class="type">List</span>[<span class="built_in">int</span>] = [<span class="number">1</span>]</span><br><span class="line">x: <span class="type">Set</span>[<span class="built_in">int</span>] = {<span class="number">6</span>, <span class="number">7</span>}</span><br><span class="line"><span class="comment"># 与上述相同，但具有类型注释语法</span></span><br><span class="line">x = [<span class="number">1</span>]  <span class="comment"># type: <span class="type">List</span>[<span class="built_in">int</span>]</span></span><br><span class="line"><span class="comment"># 对于映射，需要键和值的类型</span></span><br><span class="line">x: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">float</span>] = {<span class="string">'field'</span>: <span class="number">2.0</span>}</span><br><span class="line"><span class="comment"># 对于固定大小的元组，指定所有元素的类型</span></span><br><span class="line">x: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">str</span>, <span class="built_in">float</span>] = (<span class="number">3</span>, <span class="string">"yes"</span>, <span class="number">7.5</span>)</span><br><span class="line"><span class="comment"># 对于可变大小的元组，使用一种类型和省略号</span></span><br><span class="line">x: <span class="type">Tuple</span>[<span class="built_in">int</span>, ...] = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 使用 Optional[] 表示可能为 None 的值</span></span><br><span class="line">x: <span class="type">Optional</span>[<span class="built_in">str</span>] = some_function()</span><br><span class="line"><span class="comment"># Mypy 理解 if 语句中的值不能为 None</span></span><br><span class="line"><span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(x.upper())</span><br><span class="line"><span class="comment"># 如果由于某些不变量而使值永远不能为 None，请使用断言</span></span><br><span class="line"><span class="keyword">assert</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"><span class="built_in">print</span>(x.upper())</span><br></pre></td></tr></table></figure>
<p>函数</p>
<p>Python 3 支持函数声明的注释语法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Callable</span>, Iterator, <span class="type">Union</span>, <span class="type">Optional</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释函数定义的方式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stringify</span>(<span class="params">num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多个参数的方式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params">num1: <span class="built_in">int</span>, num2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在类型注释后为参数添加默认值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">num1: <span class="built_in">int</span>, my_float: <span class="built_in">float</span> = <span class="number">3.5</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> num1 + my_float</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释可调用（函数）值的方式, lambda 可以此方法</span></span><br><span class="line">x: <span class="type">Callable</span>[[<span class="built_in">int</span>, <span class="built_in">float</span>], <span class="built_in">float</span>] = f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生整数的生成器函数安全地返回只是一个</span></span><br><span class="line"><span class="comment"># 整数迭代器的函数，因此这就是我们对其进行注释的方式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; Iterator[<span class="built_in">int</span>]:</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以将功能注释分成多行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_email</span>(<span class="params">address: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="built_in">str</span>]],</span></span><br><span class="line"><span class="params">               sender: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">               cc: <span class="type">Optional</span>[<span class="type">List</span>[<span class="built_in">str</span>]],</span></span><br><span class="line"><span class="params">               bcc: <span class="type">Optional</span>[<span class="type">List</span>[<span class="built_in">str</span>]],</span></span><br><span class="line"><span class="params">               subject=<span class="string">''</span>,</span></span><br><span class="line"><span class="params">               body: <span class="type">Optional</span>[<span class="type">List</span>[<span class="built_in">str</span>]] = <span class="literal">None</span></span></span><br><span class="line"><span class="params">               </span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>混杂结构</p>
<p>以下是一些复杂结构的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span>, <span class="type">Any</span>, <span class="type">List</span>, <span class="type">Optional</span>, cast</span><br><span class="line"></span><br><span class="line"><span class="comment"># Union 表示可能是以下几种类型</span></span><br><span class="line">x: <span class="type">List</span>[<span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>]] = [<span class="number">3</span>, <span class="number">5</span>, <span class="string">"test"</span>, <span class="string">"fun"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不知道类型或它太动态而无法为它编写类型，请使用 Any</span></span><br><span class="line">x: <span class="type">Any</span> = mystery_function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用空容器或“无”初始化变量</span></span><br><span class="line"><span class="comment"># 类型注解帮助 mypy 获知类型信息</span></span><br><span class="line">x: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line">x: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个位置 arg 和每个关键字 arg 均为 str</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, *args: <span class="built_in">str</span>, **kwargs: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    request = make_request(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> self.do_api_query(request)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cast 可以转换类型</span></span><br><span class="line">a = [<span class="number">4</span>]</span><br><span class="line">b = cast(<span class="type">List</span>[<span class="built_in">int</span>], a)  <span class="comment"># 正常通过</span></span><br><span class="line">c = cast(<span class="type">List</span>[<span class="built_in">str</span>], a)  <span class="comment"># 正常通过 (运行是不做检查，无影响)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要在类上使用动态属性，请使其覆盖 “ __setattr__”</span></span><br><span class="line"><span class="comment"># 或 “ __getattr__”。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># "__setattr__" 允许动态分配名称</span></span><br><span class="line"><span class="comment"># "__getattr__" 允许动态访问名称</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="comment"># 如果 x 与“值”属于同一类型，则这将允许分配给任何 A.x</span></span><br><span class="line">    <span class="comment"># （使用“value: Any”以允许任意类型）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name: <span class="built_in">str</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果 x 与返回类型兼容，则将允许访问任何 A.x</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>: ...</span><br><span class="line"></span><br><span class="line">a.foo = <span class="number">42</span>  <span class="comment"># Works</span></span><br><span class="line">a.bar = <span class="string">'Ex-parrot'</span>  <span class="comment"># Fails type checking</span></span><br></pre></td></tr></table></figure>
<p>用户定义的泛型类型</p>
<p>用户定义的类可以定义为泛型类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, <span class="type">Generic</span></span><br><span class="line"><span class="keyword">from</span> logging <span class="keyword">import</span> Logger</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">'T'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggedVar</span>(<span class="type">Generic</span>[T]):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value: T, name: <span class="built_in">str</span>, logger: Logger</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.name = name</span><br><span class="line">        self.logger = logger</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, new: T</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.log(<span class="string">'Set '</span> + <span class="built_in">repr</span>(self.value))</span><br><span class="line">        self.value = new</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>) -&gt; T:</span><br><span class="line">        self.log(<span class="string">'Get '</span> + <span class="built_in">repr</span>(self.value))</span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">self, message: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.logger.info(<span class="string">'%s: %s'</span>, self.name, message)</span><br></pre></td></tr></table></figure>
<p>Generic[T] 是定义类 LoggedVar 的基类，该类使用单类型参数 T。在该类体内，T 是有效的类型。</p>
<p>lambda 的类型标注</p>
<p>由于类型注解的语法和 lambda 的语法冲突，因此不能直接对 lambda 做类型注解，但我们可以将 lambda 传给一个变量，通过对这个变量做 lambda，达到相同的目的。以下对 lambda 的几个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Callable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># is_even 传入 int 返回布尔</span></span><br><span class="line">is_even: <span class="type">Callable</span>[[<span class="built_in">int</span>], <span class="built_in">bool</span>] = <span class="keyword">lambda</span> x: (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="comment"># func 传入两个字符串，返回 int</span></span><br><span class="line">func: <span class="type">Callable</span>[[<span class="built_in">str</span>, <span class="built_in">str</span>], <span class="built_in">int</span>] = <span class="keyword">lambda</span> var1, var2: var1.index(var2)</span><br></pre></td></tr></table></figure>
<p>鸭子类型</p>
<p>在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。</p>
<p>在典型的 Python 代码中，许多可以将列表或 dict 作为参数的函数只需要将其参数设为“类似于列表”（list-like）或“类似于 dict”（dict-like）即可。 “类似列表”或“类似字典”（或类似其他的东西）的特定含义被称为「鸭子类型」，并且标准化了在惯用Python中常见的几种鸭子类型。</p>
<h3 id="ABC"><a href="#ABC" class="headerlink" title="ABC"></a>ABC</h3><p><strong>1 抽象类的概念</strong></p>
<p>抽象类是一种特殊的类， 只能被继承 不能被实例化， 子类需要实现基类指定的抽象方法 。</p>
<p>抽象基类可以不实现具体的方法（当然也可以实现，只不过子类如果想调用抽象基类中定义的接口需要使用super()）而是将其留给派生类实现。抽象基类可以被子类直接继承，也可以将其他的类”注册“（register）到其门下当虚拟子类，虚拟子类的好处是你实现的第三方子类不需要直接继承自基类但是仍然可以声称自己子类中的方法实现了基类规定的接口（issubclass(), issubinstance()）！</p>
<p> 2 抽象类的作用</p>
<p>主要是：</p>
<ul>
<li>用于处理继承问题方面更加规范、系统</li>
<li>明确调用之间的相互关系</li>
<li><strong>使得继承层次更加清晰 限定子类实现的方法</strong></li>
<li><strong>抽象类的编程，让每个人可以关注当前抽象类的方法和描述，而不需要考虑过多的实现细节，这对协同开发有很大意义，也让代码可读性更高。</strong></li>
</ul>
<p>3 metaclass 以及 abc 相关内容</p>
<p>metaclass是“类的类”，秉承Python“一切皆对象”的理念，Python中的类也是一类对象，metaclass的实例就是类（class），自己写metaclass时需要让其继承自type对象。也就是说<strong>metaclass</strong>的实例化结果是<strong>类</strong>，而<strong>class</strong>实例化的结果是<strong>instance</strong>。</p>
<p>可以这么理解的： <strong>metaclass</strong>是创建类的模板，所有的类都是通过他来create的(调用<strong>new</strong>)，这使得你可以自由的控制 创建类的那个过程，实现你所需要的功能。</p>
<p>metaclass主要用处：</p>
<ol>
<li>你可以自由的、动态的修改/增加/删除 类的或者实例中的方法或者属性</li>
<li>批量的对某些方法使用decorator，而不需要每次都在方法的上面加入@decorator_func</li>
<li>当引入第三方库的时候，如果该库某些类需要patch的时候可以用metaclass</li>
<li>可以用于序列化(参见yaml这个库的实现，我没怎么仔细看）</li>
<li>提供接口注册，接口格式检查等</li>
<li>自动委托(auto delegate)</li>
</ol>
<p>metaclass的缺点:</p>
<ul>
<li>metaclass的使用原则： If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why). —Tim Peters 也就是说如果你不知道能用metaclass来干什么的话，你尽量不要用，因为通常metaclass的代码会增加代码的复杂度， 降低代码的可读性。所以你必需权衡metaclass的利弊。</li>
<li>metaclass的优势在于它的动态性和可描述性（比如上面例子中的self.delegate.<strong>getitem</strong>(i)这样的代码，它 可以用另外的函数代码生成,而无需每次手动编写）, 它能把类的动态性扩展到极</li>
</ul>
<hr>
<p>ABC（抽象基类），主要定义了基本类和最基本的抽象方法，可以为子类定义共有的API，不需要具体实现。</p>
<p>abc模块，Python 对于ABC的支持模块，定义了一个特殊的metaclass—— ABCMeta 还有一些装饰器—— @abstractmethod 和 @abstarctproperty 。</p>
<p>abc.ABCMeta 是一个metaclass，用于在Python程序中创建抽象基类。</p>
<p>抽象基类可以不实现具体的方法（当然也可以实现，只不过子类如果想调用抽象基类中定义的接口需要使用super()）而是将其留给派生类实现。抽象基类可以被子类直接继承，也可以将其他的类”注册“（register）到其门下当虚拟子类，虚拟子类的好处是你实现的第三方子类不需要直接继承自基类但是仍然可以声称自己子类中的方法实现了基类规定的接口（issubclass(), issubinstance()）！</p>
<p>虚拟子类是通过调用metaclass是 abc.ABCMeta 的抽象基类的 register 方法注册到抽象基类门下的，可以实现抽象基类中的部分API接口，也可以根本不实现，但是issubclass(), issubinstance()进行判断时仍然返回真值。</p>
<p>直接继承抽象基类的子类就没有这么灵活，在metaclass是 abc.ABCMeta的抽象基类中可以声明”抽象方法“和“抽象属性”，直接继承自抽象基类的子类虽然判断issubclass()时为真，但只有完全覆写（实现）了抽象基类中的“抽象”内容后，才能被实例化，而通过注册的虚拟子类则不受此影响。</p>
<p>metaclass为 abc.ABCMeta 的抽象基类如果想要声明“抽象方法”，可以使用abc模块中的装饰器 @abstractmethod ，如果想声明“抽象属性”，可以使用abc模块中的 @abstractproperty 。</p>
<p>最后，为什么要提six模块呢，six模块是Python为了兼容Python 2.x 和Python 3.x提供的一个模块，该模块中有一个针对类的装饰器 @six.add_metaclass(MetaClass) 可以为两个版本的Python类方便地添加metaclass。这样我们就可以同时利用Python中的abc模块和six模块在类的定义前添加 @six.add_metaclass(abc.ABCMeta) 来优雅地声明一个抽象基础类了！</p>
<p>4 使用举例</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import abc  # 利用abc模块实现抽象类  </span><br><span class="line">class File(metaclass=abc.ABCMeta):  # abc.ABCMeta是实现抽象类的一个基础类     </span><br><span class="line">    @abc.abstractmethod  # 定义抽象方法，无需实现功能     </span><br><span class="line">    def read(self):         </span><br><span class="line">        pass  </span><br><span class="line">class Txt(File):  # 子类继承抽象类，但是必须定义read方法将抽象类中的read方法覆盖     </span><br><span class="line">    def read(self):         </span><br><span class="line">        print('文本数据的读取方法')  </span><br><span class="line">txt1 = Txt() </span><br><span class="line">txt1.read() #可以正常打印</span><br><span class="line">txt2 = File() </span><br><span class="line">txt2.read() #会报错 提示未实现</span><br></pre></td></tr></table></figure>
<p><code>abc.ABC</code>基本上只是<code>metaclass=abc.ABCMeta</code>上的一个额外层。i、 e<code>abc.ABC</code>隐式地为我们定义元类。</p>
<p>（来源：<a target="_blank" rel="noopener" href="https://hg.python.org/cpython/file/3.4/Lib/abc.py#l234）">https://hg.python.org/cpython/file/3.4/Lib/abc.py#l234）</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ABC</span>(metaclass=ABCMeta):</span><br><span class="line">    <span class="string">"""Helper class that provides a standard way to create an ABC using</span></span><br><span class="line"><span class="string">    inheritance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>唯一的区别是，在前一种情况下，您需要一个简单的继承，在后一种情况下，您需要指定元类。</p>
<p>来自<a target="_blank" rel="noopener" href="https://docs.python.org/3/whatsnew/3.4.html#abc">What’s new in Python 3.4</a>（强调我的）：</p>
<p>New class <code>ABC</code> has <code>ABCMeta</code> as its meta class. Using <code>ABC</code> as a base class has essentially the same effect as specifying <code>metaclass=abc.ABCMeta</code>, <strong>but is simpler to type and easier to read</strong>.</p>
<p>Abstract base classes由一组接口组成，检查比hasattr()更严格。通过定义一个抽象基类，可以为一组子类定义一个通用的API。这对于第三方为应用提供插件等非常有用，另外当您在一个大型的团队中工作或在一个大型的代码库中，同时将所有的类放在您的头脑中是困难或不可能的时，它也可以帮助您。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC,abstractmethod</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span>(<span class="title class_ inherited__">animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"speak"</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">c=cat()</span><br></pre></td></tr></table></figure>
<h3 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h3><p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html">官方教程</a></p>
<p>本模块标准化了一个快速、高效利用内存的核心工具集，这些工具本身或组合都很有用。它们一起形成了“迭代器代数”，这使得在纯Python中有可能创建简洁又高效的专用工具。</p>
<p><strong>无穷迭代器：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">迭代器</th>
<th style="text-align:left">实参</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.count"><code>count()</code></a></td>
<td style="text-align:left">start, [step]</td>
<td style="text-align:left">start, start+step, start+2*step, …</td>
<td style="text-align:left"><code>count(10) --&gt; 10 11 12 13 14 ...</code></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.cycle"><code>cycle()</code></a></td>
<td style="text-align:left">p</td>
<td style="text-align:left">p0, p1, … plast, p0, p1, …</td>
<td style="text-align:left"><code>cycle('ABCD') --&gt; A B C D A B C D ...</code></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.repeat"><code>repeat()</code></a></td>
<td style="text-align:left">elem [,n]</td>
<td style="text-align:left">elem, elem, elem, … 重复无限次或n次</td>
<td style="text-align:left"><code>repeat(10, 3) --&gt; 10 10 10</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>根据最短输入序列长度停止的迭代器：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">迭代器</th>
<th style="text-align:left">实参</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.accumulate"><code>accumulate()</code></a></td>
<td style="text-align:left">p [,func]</td>
<td style="text-align:left">p0, p0+p1, p0+p1+p2, …</td>
<td style="text-align:left"><code>accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15</code></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.chain"><code>chain()</code></a></td>
<td style="text-align:left">p, q, …</td>
<td style="text-align:left">p0, p1, … plast, q0, q1, …</td>
<td style="text-align:left"><code>chain('ABC', 'DEF') --&gt; A B C D E F</code></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.chain.from_iterable"><code>chain.from_iterable()</code></a></td>
<td style="text-align:left">iterable — 可迭代对象</td>
<td style="text-align:left">p0, p1, … plast, q0, q1, …</td>
<td style="text-align:left"><code>chain.from_iterable(['ABC', 'DEF']) --&gt; A B C D E F</code></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.compress"><code>compress()</code></a></td>
<td style="text-align:left">data, selectors</td>
<td style="text-align:left">(d[0] if s[0]), (d[1] if s[1]), …</td>
<td style="text-align:left"><code>compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F</code></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.dropwhile"><code>dropwhile()</code></a></td>
<td style="text-align:left">pred, seq</td>
<td style="text-align:left">seq[n], seq[n+1], … 从pred首次真值测试失败开始</td>
<td style="text-align:left"><code>dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</code></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.filterfalse"><code>filterfalse()</code></a></td>
<td style="text-align:left">pred, seq</td>
<td style="text-align:left">seq中pred(x)为假值的元素，x是seq中的元素。</td>
<td style="text-align:left"><code>filterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8</code></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.groupby"><code>groupby()</code></a></td>
<td style="text-align:left">iterable[, key]</td>
<td style="text-align:left">根据key(v)值分组的迭代器</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.islice"><code>islice()</code></a></td>
<td style="text-align:left">seq, [start,] stop [, step]</td>
<td style="text-align:left">seq[start:stop:step]中的元素</td>
<td style="text-align:left"><code>islice('ABCDEFG', 2, None) --&gt; C D E F G</code></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.pairwise"><code>pairwise()</code></a></td>
<td style="text-align:left">iterable — 可迭代对象</td>
<td style="text-align:left">(p[0], p[1]), (p[1], p[2])</td>
<td style="text-align:left"><code>pairwise('ABCDEFG') --&gt; AB BC CD DE EF FG</code></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.starmap"><code>starmap()</code></a></td>
<td style="text-align:left">func, seq</td>
<td style="text-align:left">func(<em>seq[0]), func(</em>seq[1]), …</td>
<td style="text-align:left"><code>starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000</code></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.takewhile"><code>takewhile()</code></a></td>
<td style="text-align:left">pred, seq</td>
<td style="text-align:left">seq[0], seq[1], …, 直到pred真值测试失败</td>
<td style="text-align:left"><code>takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</code></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.tee"><code>tee()</code></a></td>
<td style="text-align:left">it, n</td>
<td style="text-align:left">it1, it2, … itn 将一个迭代器拆分为n个迭代器</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.zip_longest"><code>zip_longest()</code></a></td>
<td style="text-align:left">p, q, …</td>
<td style="text-align:left">(p[0], q[0]), (p[1], q[1]), …</td>
<td style="text-align:left"><code>zip_longest('ABCD', 'xy', fillvalue='-') --&gt; Ax By C- D-</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>排列组合迭代器：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">迭代器</th>
<th style="text-align:left">实参</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.product"><code>product()</code></a></td>
<td style="text-align:left">p, q, … [repeat=1]</td>
<td style="text-align:left">笛卡尔积，相当于嵌套的for循环</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.permutations"><code>permutations()</code></a></td>
<td style="text-align:left">p[, r]</td>
<td style="text-align:left">长度r元组，所有可能的排列，无重复元素</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.combinations"><code>combinations()</code></a></td>
<td style="text-align:left">p, r</td>
<td style="text-align:left">长度r元组，有序，无重复元素</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.combinations_with_replacement"><code>combinations_with_replacement()</code></a></td>
<td style="text-align:left">p, r</td>
<td style="text-align:left">长度r元组，有序，元素可重复</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">例子</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>product('ABCD', repeat=2)</code></td>
<td style="text-align:left"><code>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</code></td>
</tr>
<tr>
<td style="text-align:left"><code>permutations('ABCD', 2)</code></td>
<td style="text-align:left"><code>AB AC AD BA BC BD CA CB CD DA DB DC</code></td>
</tr>
<tr>
<td style="text-align:left"><code>combinations('ABCD', 2)</code></td>
<td style="text-align:left"><code>AB AC AD BC BD CD</code></td>
</tr>
<tr>
<td style="text-align:left"><code>combinations_with_replacement('ABCD', 2)</code></td>
<td style="text-align:left"><code>AA AB AC AD BB BC BD CC CD DD</code></td>
</tr>
</tbody>
</table>
</div>
<p> <strong>Itertool函数</strong></p>
<p>下列模块函数均创建并返回迭代器。有些迭代器不限制输出流长度，所以它们只应在能截断输出流的函数或循环中使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itertools.accumulate(iterable[, func, *, initial=None])</span><br></pre></td></tr></table></figure>
<p>创建一个迭代器，返回累积汇总值或其他双目运算函数的累积结果值（通过可选的 <em>func</em> 参数指定）。</p>
<p>如果提供了 <em>func</em>，它应当为带有两个参数的函数。 输入 <em>iterable</em> 的元素可以是能被 <em>func</em> 接受为参数的任意类型。 （例如，对于默认的加法运算，元素可以是任何可相加的类型包括 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal"><code>Decimal</code></a> 或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/fractions.html#fractions.Fraction"><code>Fraction</code></a>。）</p>
<p>通常，输出的元素数量与输入的可迭代对象是一致的。 但是，如果提供了关键字参数 <em>initial</em>，则累加会以 <em>initial</em> 值开始，这样输出就比输入的可迭代对象多一个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accumulate</span>(<span class="params">iterable, func=operator.add, *, initial=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">'Return running totals'</span></span><br><span class="line">    <span class="comment"># accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15</span></span><br><span class="line">    <span class="comment"># accumulate([1,2,3,4,5], initial=100) --&gt; 100 101 103 106 110 115</span></span><br><span class="line">    <span class="comment"># accumulate([1,2,3,4,5], operator.mul) --&gt; 1 2 6 24 120</span></span><br><span class="line">    it = <span class="built_in">iter</span>(iterable)</span><br><span class="line">    total = initial</span><br><span class="line">    <span class="keyword">if</span> initial <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            total = <span class="built_in">next</span>(it)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> total</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">        total = func(total, element)</span><br><span class="line">        <span class="keyword">yield</span> total</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202305021500432.png" alt="image-20230502150032323"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itertools.chain(*iterables)</span><br></pre></td></tr></table></figure>
<p>创建一个迭代器，它首先返回第一个可迭代对象中所有元素，接着返回下一个可迭代对象中所有元素，直到耗尽所有可迭代对象中的元素。可将多个序列处理为单个序列。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">chain</span>(<span class="params">*iterables</span>):</span><br><span class="line">    <span class="comment"># chain('ABC', 'DEF') --&gt; A B C D E F</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">            <span class="keyword">yield</span> element</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itertools.count(start=0, step=1)</span><br></pre></td></tr></table></figure>
<p>创建一个迭代器，它从 <em>start</em> 值开始，返回均匀间隔的值。常用于 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#map"><code>map()</code></a> 中的实参来生成连续的数据点。此外，还用于 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#zip"><code>zip()</code></a> 来添加序列号。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">start=<span class="number">0</span>, step=<span class="number">1</span></span>):</span><br><span class="line">    <span class="comment"># count(10) --&gt; 10 11 12 13 14 ...</span></span><br><span class="line">    <span class="comment"># count(2.5, 0.5) --&gt; 2.5 3.0 3.5 ...</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += step</span><br></pre></td></tr></table></figure>
<p>当对浮点数计数时，替换为乘法代码有时精度会更好，例如： <code>(start + step * i for i in count())</code> 。</p>
<p> itertools 配方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">take</span>(<span class="params">n, iterable</span>):</span><br><span class="line">    <span class="string">"Return first n items of the iterable as a list"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(islice(iterable, n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepend</span>(<span class="params">value, iterator</span>):</span><br><span class="line">    <span class="string">"Prepend a single value in front of an iterator"</span></span><br><span class="line">    <span class="comment"># prepend(1, [2, 3, 4]) --&gt; 1 2 3 4</span></span><br><span class="line">    <span class="keyword">return</span> chain([value], iterator)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tabulate</span>(<span class="params">function, start=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">"Return function(0), function(1), ..."</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(function, count(start))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tail</span>(<span class="params">n, iterable</span>):</span><br><span class="line">    <span class="string">"Return an iterator over the last n items"</span></span><br><span class="line">    <span class="comment"># tail(3, 'ABCDEFG') --&gt; E F G</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iter</span>(collections.deque(iterable, maxlen=n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consume</span>(<span class="params">iterator, n=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">"Advance the iterator n-steps ahead. If n is None, consume entirely."</span></span><br><span class="line">    <span class="comment"># Use functions that consume iterators at C speed.</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># feed the entire iterator into a zero-length deque</span></span><br><span class="line">        collections.deque(iterator, maxlen=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># advance to the empty slice starting at position n</span></span><br><span class="line">        <span class="built_in">next</span>(islice(iterator, n, n), <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nth</span>(<span class="params">iterable, n, default=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">"Returns the nth item or a default value"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">next</span>(islice(iterable, n, <span class="literal">None</span>), default)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">all_equal</span>(<span class="params">iterable</span>):</span><br><span class="line">    <span class="string">"Returns True if all the elements are equal to each other"</span></span><br><span class="line">    g = groupby(iterable)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">next</span>(g, <span class="literal">True</span>) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">next</span>(g, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quantify</span>(<span class="params">iterable, pred=<span class="built_in">bool</span></span>):</span><br><span class="line">    <span class="string">"Count how many times the predicate is True"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">map</span>(pred, iterable))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ncycles</span>(<span class="params">iterable, n</span>):</span><br><span class="line">    <span class="string">"Returns the sequence elements n times"</span></span><br><span class="line">    <span class="keyword">return</span> chain.from_iterable(repeat(<span class="built_in">tuple</span>(iterable), n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">batched</span>(<span class="params">iterable, n</span>):</span><br><span class="line">    <span class="string">"Batch data into tuples of length n. The last batch may be shorter."</span></span><br><span class="line">    <span class="comment"># batched('ABCDEFG', 3) --&gt; ABC DEF G</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'n must be at least one'</span>)</span><br><span class="line">    it = <span class="built_in">iter</span>(iterable)</span><br><span class="line">    <span class="keyword">while</span> batch := <span class="built_in">tuple</span>(islice(it, n)):</span><br><span class="line">        <span class="keyword">yield</span> batch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grouper</span>(<span class="params">iterable, n, *, incomplete=<span class="string">'fill'</span>, fillvalue=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">"Collect data into non-overlapping fixed-length chunks or blocks"</span></span><br><span class="line">    <span class="comment"># grouper('ABCDEFG', 3, fillvalue='x') --&gt; ABC DEF Gxx</span></span><br><span class="line">    <span class="comment"># grouper('ABCDEFG', 3, incomplete='strict') --&gt; ABC DEF ValueError</span></span><br><span class="line">    <span class="comment"># grouper('ABCDEFG', 3, incomplete='ignore') --&gt; ABC DEF</span></span><br><span class="line">    args = [<span class="built_in">iter</span>(iterable)] * n</span><br><span class="line">    <span class="keyword">if</span> incomplete == <span class="string">'fill'</span>:</span><br><span class="line">        <span class="keyword">return</span> zip_longest(*args, fillvalue=fillvalue)</span><br><span class="line">    <span class="keyword">if</span> incomplete == <span class="string">'strict'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">zip</span>(*args, strict=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> incomplete == <span class="string">'ignore'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">zip</span>(*args)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Expected fill, strict, or ignore'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sumprod</span>(<span class="params">vec1, vec2</span>):</span><br><span class="line">    <span class="string">"Compute a sum of products."</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(starmap(operator.mul, <span class="built_in">zip</span>(vec1, vec2, strict=<span class="literal">True</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_of_squares</span>(<span class="params">it</span>):</span><br><span class="line">    <span class="string">"Add up the squares of the input values."</span></span><br><span class="line">    <span class="comment"># sum_of_squares([10, 20, 30]) -&gt; 1400</span></span><br><span class="line">    <span class="keyword">return</span> sumprod(*tee(it))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transpose</span>(<span class="params">it</span>):</span><br><span class="line">    <span class="string">"Swap the rows and columns of the input."</span></span><br><span class="line">    <span class="comment"># transpose([(1, 2, 3), (11, 22, 33)]) --&gt; (1, 11) (2, 22) (3, 33)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">zip</span>(*it, strict=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matmul</span>(<span class="params">m1, m2</span>):</span><br><span class="line">    <span class="string">"Multiply two matrices."</span></span><br><span class="line">    <span class="comment"># matmul([(7, 5), (3, 5)], [[2, 5], [7, 9]]) --&gt; (49, 80), (41, 60)</span></span><br><span class="line">    n = <span class="built_in">len</span>(m2[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> batched(starmap(sumprod, product(m1, transpose(m2))), n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convolve</span>(<span class="params">signal, kernel</span>):</span><br><span class="line">    <span class="comment"># See:  https://betterexplained.com/articles/intuitive-convolution/</span></span><br><span class="line">    <span class="comment"># convolve(data, [0.25, 0.25, 0.25, 0.25]) --&gt; Moving average (blur)</span></span><br><span class="line">    <span class="comment"># convolve(data, [1, -1]) --&gt; 1st finite difference (1st derivative)</span></span><br><span class="line">    <span class="comment"># convolve(data, [1, -2, 1]) --&gt; 2nd finite difference (2nd derivative)</span></span><br><span class="line">    kernel = <span class="built_in">tuple</span>(kernel)[::-<span class="number">1</span>]</span><br><span class="line">    n = <span class="built_in">len</span>(kernel)</span><br><span class="line">    window = collections.deque([<span class="number">0</span>], maxlen=n) * n</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> chain(signal, repeat(<span class="number">0</span>, n-<span class="number">1</span>)):</span><br><span class="line">        window.append(x)</span><br><span class="line">        <span class="keyword">yield</span> sumprod(kernel, window)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">polynomial_from_roots</span>(<span class="params">roots</span>):</span><br><span class="line">    <span class="string">"""Compute a polynomial's coefficients from its roots.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       (x - 5) (x + 4) (x - 3)  expands to:   x³ -4x² -17x + 60</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># polynomial_from_roots([5, -4, 3]) --&gt; [1, -4, -17, 60]</span></span><br><span class="line">    expansion = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> roots:</span><br><span class="line">        expansion = convolve(expansion, (<span class="number">1</span>, -r))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(expansion)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">polynomial_eval</span>(<span class="params">coefficients, x</span>):</span><br><span class="line">    <span class="string">"""Evaluate a polynomial at a specific value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Computes with better numeric stability than Horner's method.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Evaluate x³ -4x² -17x + 60 at x = 2.5</span></span><br><span class="line">    <span class="comment"># polynomial_eval([1, -4, -17, 60], x=2.5) --&gt; 8.125</span></span><br><span class="line">    n = <span class="built_in">len</span>(coefficients)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">0</span>  <span class="comment"># coerce zero to the type of x</span></span><br><span class="line">    powers = <span class="built_in">map</span>(<span class="built_in">pow</span>, repeat(x), <span class="built_in">reversed</span>(<span class="built_in">range</span>(n)))</span><br><span class="line">    <span class="keyword">return</span> sumprod(coefficients, powers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iter_index</span>(<span class="params">iterable, value, start=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">"Return indices where a value occurs in a sequence or iterable."</span></span><br><span class="line">    <span class="comment"># iter_index('AABCADEAF', 'A') --&gt; 0 1 4 7</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        seq_index = iterable.index</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="comment"># Slow path for general iterables</span></span><br><span class="line">        it = islice(iterable, start, <span class="literal">None</span>)</span><br><span class="line">        i = start - <span class="number">1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">yield</span> (i := i + operator.indexOf(it, value) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Fast path for sequences</span></span><br><span class="line">        i = start - <span class="number">1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">yield</span> (i := seq_index(value, i+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sieve</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">"Primes less than n"</span></span><br><span class="line">    <span class="comment"># sieve(30) --&gt; 2 3 5 7 11 13 17 19 23 29</span></span><br><span class="line">    data = <span class="built_in">bytearray</span>((<span class="number">0</span>, <span class="number">1</span>)) * (n // <span class="number">2</span>)</span><br><span class="line">    data[:<span class="number">3</span>] = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    limit = math.isqrt(n) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> compress(<span class="built_in">range</span>(limit), data):</span><br><span class="line">        data[p*p : n : p+p] = <span class="built_in">bytes</span>(<span class="built_in">len</span>(<span class="built_in">range</span>(p*p, n, p+p)))</span><br><span class="line">    data[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> iter_index(data, <span class="number">1</span>) <span class="keyword">if</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> <span class="built_in">iter</span>([])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factor</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">"Prime factors of n."</span></span><br><span class="line">    <span class="comment"># factor(99) --&gt; 3 3 11</span></span><br><span class="line">    <span class="keyword">for</span> prime <span class="keyword">in</span> sieve(math.isqrt(n) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            quotient, remainder = <span class="built_in">divmod</span>(n, prime)</span><br><span class="line">            <span class="keyword">if</span> remainder:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">yield</span> prime</span><br><span class="line">            n = quotient</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">list_of_lists</span>):</span><br><span class="line">    <span class="string">"Flatten one level of nesting"</span></span><br><span class="line">    <span class="keyword">return</span> chain.from_iterable(list_of_lists)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeatfunc</span>(<span class="params">func, times=<span class="literal">None</span>, *args</span>):</span><br><span class="line">    <span class="string">"""Repeat calls to func with specified arguments.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Example:  repeatfunc(random.random)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> times <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> starmap(func, repeat(args))</span><br><span class="line">    <span class="keyword">return</span> starmap(func, repeat(args, times))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">triplewise</span>(<span class="params">iterable</span>):</span><br><span class="line">    <span class="string">"Return overlapping triplets from an iterable"</span></span><br><span class="line">    <span class="comment"># triplewise('ABCDEFG') --&gt; ABC BCD CDE DEF EFG</span></span><br><span class="line">    <span class="keyword">for</span> (a, _), (b, c) <span class="keyword">in</span> pairwise(pairwise(iterable)):</span><br><span class="line">        <span class="keyword">yield</span> a, b, c</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window</span>(<span class="params">iterable, n</span>):</span><br><span class="line">    <span class="comment"># sliding_window('ABCDEFG', 4) --&gt; ABCD BCDE CDEF DEFG</span></span><br><span class="line">    it = <span class="built_in">iter</span>(iterable)</span><br><span class="line">    window = collections.deque(islice(it, n), maxlen=n)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(window) == n:</span><br><span class="line">        <span class="keyword">yield</span> <span class="built_in">tuple</span>(window)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">        window.append(x)</span><br><span class="line">        <span class="keyword">yield</span> <span class="built_in">tuple</span>(window)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">roundrobin</span>(<span class="params">*iterables</span>):</span><br><span class="line">    <span class="string">"roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"</span></span><br><span class="line">    <span class="comment"># Recipe credited to George Sakkis</span></span><br><span class="line">    num_active = <span class="built_in">len</span>(iterables)</span><br><span class="line">    nexts = cycle(<span class="built_in">iter</span>(it).__next__ <span class="keyword">for</span> it <span class="keyword">in</span> iterables)</span><br><span class="line">    <span class="keyword">while</span> num_active:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> nexts:</span><br><span class="line">                <span class="keyword">yield</span> <span class="built_in">next</span>()</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="comment"># Remove the iterator we just exhausted from the cycle.</span></span><br><span class="line">            num_active -= <span class="number">1</span></span><br><span class="line">            nexts = cycle(islice(nexts, num_active))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">pred, iterable</span>):</span><br><span class="line">    <span class="string">"Use a predicate to partition entries into false entries and true entries"</span></span><br><span class="line">    <span class="comment"># partition(is_odd, range(10)) --&gt; 0 2 4 6 8   and  1 3 5 7 9</span></span><br><span class="line">    t1, t2 = tee(iterable)</span><br><span class="line">    <span class="keyword">return</span> filterfalse(pred, t1), <span class="built_in">filter</span>(pred, t2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">before_and_after</span>(<span class="params">predicate, it</span>):</span><br><span class="line">    <span class="string">""" Variant of takewhile() that allows complete</span></span><br><span class="line"><span class="string">        access to the remainder of the iterator.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; it = iter('ABCdEfGhI')</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_upper, remainder = before_and_after(str.isupper, it)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; ''.join(all_upper)</span></span><br><span class="line"><span class="string">        'ABC'</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; ''.join(remainder)     # takewhile() would lose the 'd'</span></span><br><span class="line"><span class="string">        'dEfGhI'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Note that the first iterator must be fully</span></span><br><span class="line"><span class="string">        consumed before the second iterator can</span></span><br><span class="line"><span class="string">        generate valid results.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    it = <span class="built_in">iter</span>(it)</span><br><span class="line">    transition = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">true_iterator</span>():</span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> it:</span><br><span class="line">            <span class="keyword">if</span> predicate(elem):</span><br><span class="line">                <span class="keyword">yield</span> elem</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                transition.append(elem)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remainder_iterator</span>():</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> transition</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> it</span><br><span class="line">    <span class="keyword">return</span> true_iterator(), remainder_iterator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subslices</span>(<span class="params">seq</span>):</span><br><span class="line">    <span class="string">"Return all contiguous non-empty subslices of a sequence"</span></span><br><span class="line">    <span class="comment"># subslices('ABCD') --&gt; A AB ABC ABCD B BC BCD C CD D</span></span><br><span class="line">    slices = starmap(<span class="built_in">slice</span>, combinations(<span class="built_in">range</span>(<span class="built_in">len</span>(seq) + <span class="number">1</span>), <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(operator.getitem, repeat(seq), slices)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">powerset</span>(<span class="params">iterable</span>):</span><br><span class="line">    <span class="string">"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"</span></span><br><span class="line">    s = <span class="built_in">list</span>(iterable)</span><br><span class="line">    <span class="keyword">return</span> chain.from_iterable(combinations(s, r) <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unique_everseen</span>(<span class="params">iterable, key=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">"List unique elements, preserving order. Remember all elements ever seen."</span></span><br><span class="line">    <span class="comment"># unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D</span></span><br><span class="line">    <span class="comment"># unique_everseen('ABBcCAD', str.lower) --&gt; A B c D</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> filterfalse(seen.__contains__, iterable):</span><br><span class="line">            seen.add(element)</span><br><span class="line">            <span class="keyword">yield</span> element</span><br><span class="line">        <span class="comment"># For order preserving deduplication,</span></span><br><span class="line">        <span class="comment"># a faster but non-lazy solution is:</span></span><br><span class="line">        <span class="comment">#     yield from dict.fromkeys(iterable)</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">            k = key(element)</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(k)</span><br><span class="line">                <span class="keyword">yield</span> element</span><br><span class="line">        <span class="comment"># For use cases that allow the last matching element to be returned,</span></span><br><span class="line">        <span class="comment"># a faster but non-lazy solution is:</span></span><br><span class="line">        <span class="comment">#      t1, t2 = tee(iterable)</span></span><br><span class="line">        <span class="comment">#      yield from dict(zip(map(key, t1), t2)).values()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unique_justseen</span>(<span class="params">iterable, key=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">"List unique elements, preserving order. Remember only the element just seen."</span></span><br><span class="line">    <span class="comment"># unique_justseen('AAAABBBCCDAABBB') --&gt; A B C D A B</span></span><br><span class="line">    <span class="comment"># unique_justseen('ABBcCAD', str.lower) --&gt; A B c A D</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(<span class="built_in">next</span>, <span class="built_in">map</span>(operator.itemgetter(<span class="number">1</span>), groupby(iterable, key)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iter_except</span>(<span class="params">func, exception, first=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">""" Call a function repeatedly until an exception is raised.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Converts a call-until-exception interface to an iterator interface.</span></span><br><span class="line"><span class="string">    Like builtins.iter(func, sentinel) but uses an exception instead</span></span><br><span class="line"><span class="string">    of a sentinel to end the loop.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples:</span></span><br><span class="line"><span class="string">        iter_except(functools.partial(heappop, h), IndexError)   # priority queue iterator</span></span><br><span class="line"><span class="string">        iter_except(d.popitem, KeyError)                         # non-blocking dict iterator</span></span><br><span class="line"><span class="string">        iter_except(d.popleft, IndexError)                       # non-blocking deque iterator</span></span><br><span class="line"><span class="string">        iter_except(q.get_nowait, Queue.Empty)                   # loop over a producer Queue</span></span><br><span class="line"><span class="string">        iter_except(s.pop, KeyError)                             # non-blocking set iterator</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> first <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> first()            <span class="comment"># For database APIs needing an initial cast to db.first()</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">yield</span> func()</span><br><span class="line">    <span class="keyword">except</span> exception:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">first_true</span>(<span class="params">iterable, default=<span class="literal">False</span>, pred=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">"""Returns the first true value in the iterable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If no true value is found, returns *default*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If *pred* is not None, returns the first item</span></span><br><span class="line"><span class="string">    for which pred(item) is true.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># first_true([a,b,c], x) --&gt; a or b or c or x</span></span><br><span class="line">    <span class="comment"># first_true([a,b], x, f) --&gt; a if f(a) else b if f(b) else x</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">next</span>(<span class="built_in">filter</span>(pred, iterable), default)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nth_combination</span>(<span class="params">iterable, r, index</span>):</span><br><span class="line">    <span class="string">"Equivalent to list(combinations(iterable, r))[index]"</span></span><br><span class="line">    pool = <span class="built_in">tuple</span>(iterable)</span><br><span class="line">    n = <span class="built_in">len</span>(pool)</span><br><span class="line">    c = math.comb(n, r)</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">        index += c</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= c:</span><br><span class="line">        <span class="keyword">raise</span> IndexError</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> r:</span><br><span class="line">        c, n, r = c*r//n, n-<span class="number">1</span>, r-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> index &gt;= c:</span><br><span class="line">            index -= c</span><br><span class="line">            c, n = c*(n-r)//n, n-<span class="number">1</span></span><br><span class="line">        result.append(pool[-<span class="number">1</span>-n])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>在 Python 中，<code>slice</code>是一个用于切片操作的内置类，它可以用来创建切片对象，用于指定切片操作的起始位置、终止位置和步长。</p>
<p>切片操作是指从一个序列中选取一部分元素，形成一个新的序列。使用切片操作可以快速地获取序列的子集，而不需要复制整个序列。在 Python 中，切片操作可以用来处理列表、元组、字符串等序列类型数据。</p>
<p>下面是一些使用切片操作的例子：</p>
<p> <code>(class) slice</code> 是 Python 中的一个内置类，用于表示切片对象。切片对象可以作为参数传递给 <code>__getitem__()</code> 方法，用于从序列中获取一部分元素。</p>
<p><code>slice</code> 类可以通过调用 <code>slice()</code> 函数或者直接使用 <code>:</code> 运算符来创建。它有以下三种形式：</p>
<ul>
<li><code>slice(stop)</code>：用于指定终止位置为 <code>stop</code> 的切片对象，默认起始位置为 <code>None</code>，步长为 <code>None</code>。</li>
<li><code>slice(start, stop[, step])</code>：用于指定起始位置为 <code>start</code>、终止位置为 <code>stop</code>、步长为 <code>step</code> 的切片对象。其中，<code>start</code> 和 <code>step</code> 默认为 <code>None</code>，表示从序列的开头开始选取元素，并使用默认步长 1。</li>
<li><code>:</code> 运算符：用于使用切片对象简洁地表示切片范围。例如，<code>my_list[1:4]</code> 可以写成 <code>my_list[slice(1, 4)]</code> 或 <code>my_list[slice(None, 4, None)]</code>，也可以简写为 <code>my_list[1:4:1]</code> 或 <code>my_list[1:4]</code>。</li>
</ul>
<p>下面是一些使用切片对象的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表切片</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">my_slice = <span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">4</span>)    <span class="comment"># 创建切片对象</span></span><br><span class="line"><span class="built_in">print</span>(my_list[my_slice])   <span class="comment"># 输出：[2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串切片</span></span><br><span class="line">my_str = <span class="string">"Hello, world!"</span></span><br><span class="line">my_slice = <span class="built_in">slice</span>(<span class="number">7</span>, <span class="literal">None</span>)  <span class="comment"># 创建切片对象</span></span><br><span class="line"><span class="built_in">print</span>(my_str[my_slice])    <span class="comment"># 输出："world!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 ":" 简写切片范围</span></span><br><span class="line">my_slice = <span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list[my_slice])   <span class="comment"># 输出：[2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">my_slice = <span class="built_in">slice</span>(<span class="number">7</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(my_str[my_slice])    <span class="comment"># 输出："world!"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>:<span class="number">4</span>])        <span class="comment"># 输出：[2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(my_str[<span class="number">7</span>:])          <span class="comment"># 输出："world!"</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们分别使用 <code>slice()</code> 函数和 <code>:</code> 运算符创建了切片对象，并将其作为参数传递给序列的 <code>__getitem__()</code> 方法来获取子集。使用切片对象可以使代码更加清晰简洁，特别是在需要多次使用相同的切片范围时。</p>
<p>实际上，使用 <code>slice()</code> 函数构造切片和直接使用列表自带的切片方法本质上是一样的，都是用于从序列中选取子集。两种方法的区别在于使用场景和语法习惯。</p>
<p>使用 <code>slice()</code> 函数构造切片可以使代码更加清晰简洁，特别是当需要多次使用相同的切片范围时。在这种情况下，我们可以将切片对象存储在变量中，然后在需要的地方重复使用，避免了重复编写切片范围的繁琐。另外，使用 <code>slice()</code> 函数可以将切片范围与其他参数分离，使代码更具可读性。</p>
<p>例如，下面是一个使用 <code>slice()</code> 函数构造切片的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] my_slice = <span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">4</span>) <span class="built_in">print</span>(my_list[my_slice])   <span class="comment"># 输出：[2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>使用切片方法可以达到相同的效果，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>:<span class="number">4</span>])        <span class="comment"># 输出：[2, 3, 4]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是，在一些特定的情况下，使用 <code>slice()</code> 函数构造切片可以使代码更加灵活。例如，当我们需要将切片范围作为参数传递给其他函数或方法时，使用 <code>slice()</code> 函数可以更方便地进行参数的组合和重用。另外，在一些高级的应用场景中，例如对多维数组进行切片操作时，使用 <code>slice()</code> 函数可以更方便地进行切片范围的计算和组合。</p>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>在Python中，<code>zip()</code>函数用于将多个可迭代对象（如列表、元组或字符串）的元素逐个配对，返回一个新的迭代器，该迭代器生成由原始对象中对应元素组成的元组。</p>
<p><code>zip()</code>函数的语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">zip</span>(*iterables)</span><br></pre></td></tr></table></figure>
<p>其中，<code>*iterables</code>表示一个或多个可迭代对象作为参数，可以是列表、元组或其他可迭代对象。</p>
<p>下面是一些示例，以说明<code>zip()</code>函数的用法：</p>
<p><strong>示例 1：基本用法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">result = <span class="built_in">zip</span>(numbers, letters)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印配对后的元组</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">'b'</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">'c'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：配对不等长的可迭代对象</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">letters = [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">result = <span class="built_in">zip</span>(numbers, letters)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印配对后的元组</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">'b'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：当可迭代对象的长度不一致时，<code>zip()</code>函数会以最短的可迭代对象的长度为准进行配对。</p>
<p><strong>示例 3：解压缩操作</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pairs = [(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>)]</span><br><span class="line">numbers, letters = <span class="built_in">zip</span>(*pairs)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>zip()</code>函数用于将元组列表解压为两个独立的元组，其中一个元组包含所有的数字，另一个元组包含所有的字母。</p>
<p><code>zip()</code>函数在处理数据时非常有用，可以用于将多个列表的对应元素进行组合、并行迭代等操作。</p>
<h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><p>在Python中，<code>collections</code>是一个内置模块，提供了额外的数据结构，以及对数据结构的扩展和操作。它包含了一些有用的容器类型，用于处理和操作数据。下面是一些常用的<code>collections</code>数据结构：</p>
<ol>
<li><p><code>namedtuple</code>: 这是一个工厂函数，用于创建具有字段名称的元组。它可以用于创建简单的数据对象，类似于一个只有字段而没有方法的类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个具有字段名称的元组</span></span><br><span class="line">Person = namedtuple(<span class="string">'Person'</span>, [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'city'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Person 对象</span></span><br><span class="line">person1 = Person(<span class="string">'Alice'</span>, <span class="number">25</span>, <span class="string">'New York'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问字段</span></span><br><span class="line"><span class="built_in">print</span>(person1.name)  <span class="comment"># 输出：Alice</span></span><br><span class="line"><span class="built_in">print</span>(person1.age)   <span class="comment"># 输出：25</span></span><br><span class="line"><span class="built_in">print</span>(person1.city)  <span class="comment"># 输出：New York</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>deque</code>: 这是一个双端队列（double-ended queue），支持在两端高效地添加和删除元素。相比于列表（<code>list</code>），在队列的头部和尾部进行插入和删除操作的时间复杂度更低。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个双端队列</span></span><br><span class="line">d = deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在队列的右端添加元素</span></span><br><span class="line">d.append(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出：deque([1, 2, 3, 4, 5, 6])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在队列的左端添加元素</span></span><br><span class="line">d.appendleft(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出：deque([0, 1, 2, 3, 4, 5, 6])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从队列的右端弹出元素</span></span><br><span class="line">x = d.pop()</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出：6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从队列的左端弹出元素</span></span><br><span class="line">y = d.popleft()</span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 输出：0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>Counter</code>: 这是一个用于计数的字典子类，它可以快速统计可哈希对象的频次。它提供了一些便捷的方法，比如统计列表中元素的出现次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Counter 对象</span></span><br><span class="line">c = Counter([<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>, <span class="string">'apple'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计元素的频次</span></span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">'apple'</span>])   <span class="comment"># 输出：3</span></span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">'banana'</span>])  <span class="comment"># 输出：2</span></span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">'orange'</span>])  <span class="comment"># 输出：1</span></span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">'grape'</span>])   <span class="comment"># 输出：0（不存在的元素返回0）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>OrderedDict</code>: 这是一个有序字典，它记住了元素的插入顺序。与普通字典不同，<code>OrderedDict</code>的键值对的顺序是可预测的，并且在迭代时保持不变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个有序字典</span></span><br><span class="line">d = OrderedDict()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加键值对</span></span><br><span class="line">d[<span class="string">'apple'</span>] = <span class="number">2</span></span><br><span class="line">d[<span class="string">'banana'</span>] = <span class="number">3</span></span><br><span class="line">d[<span class="string">'orange'</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历字典并保持插入顺序</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># apple 2</span></span><br><span class="line"><span class="comment"># banana 3</span></span><br><span class="line"><span class="comment"># orange 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>defaultdict</code>: 这是一个具有默认值的字典，当访问一个不存在的键时，它会返回一个默认值而不是抛出<code>KeyError</code>异常。默认值的类型在创建字典时指定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个默认值为 0 的字典</span></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问不存在的键，返回默认值 0</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">'apple'</span>])  <span class="comment"># 输出：0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新字典中的值</span></span><br><span class="line">d[<span class="string">'apple'</span>] += <span class="number">2</span></span><br><span class="line">d[<span class="string">'banana'</span>] += <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">'apple'</span>])   <span class="comment"># 输出：2</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">'banana'</span>])  <span class="comment"># 输出：3</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">'orange'</span>])  <span class="comment"># 输出：0（默认值仍然是 0）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这些是<code>collections</code>模块中一些常用的数据结构，它们提供了更高级、更灵活的数据处理方式，可以帮助简化编程任务。你可以通过导入<code>collections</code>模块来使用这些数据结构，例如：<code>import collections</code>。</p>
<h3 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h3><p>在Python中，有几种不同的排序函数和方法可用于对列表或其他可迭代对象进行排序。下面是一些常用的排序函数和方法：</p>
<p><code>sorted()</code>: 这是一个内置函数，用于对可迭代对象进行排序并返回一个新的已排序列表，而不改变原始列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">sorted_numbers = <span class="built_in">sorted</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(sorted_numbers)  <span class="comment"># 输出：[1, 2, 5, 7, 9]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>list.sort()</code>: 这是列表对象的方法，用于原地排序列表，即在原始列表上进行排序，而不创建新的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">numbers.sort()</span><br><span class="line"><span class="built_in">print</span>(numbers)  <span class="comment"># 输出：[1, 2, 5, 7, 9]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>sort()</code> 函数的 <code>key</code> 参数：这是 <code>sorted()</code> 函数和 <code>list.sort()</code> 方法中的一个可选参数，用于指定排序的键或自定义排序规则。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'date'</span>]</span><br><span class="line">sorted_words = <span class="built_in">sorted</span>(words, key=<span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_words)  <span class="comment"># 输出：['date', 'apple', 'banana', 'cherry']</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>sort()</code> 函数的 <code>reverse</code> 参数：这是 <code>sorted()</code> 函数和 <code>list.sort()</code> 方法中的另一个可选参数，用于指定是否按逆序进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">numbers.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(numbers)  <span class="comment"># 输出：[9, 7, 5, 2, 1]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><h3 id="axis"><a href="#axis" class="headerlink" title="axis"></a><strong>axis</strong></h3><p>“axis=0表示跨行，axis=1表示跨列，作为方法动作的副词”</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202209061015661.png" alt="image-20220906101507580"></p>
<h3 id="save-amp-load"><a href="#save-amp-load" class="headerlink" title="save & load"></a>save &amp; load</h3><p>保存数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save</span></span><br><span class="line">np.save(<span class="string">"obs_render.npy"</span>,obs_render)</span><br><span class="line">np.save(<span class="string">"obs_list.npy"</span>,obs_list)</span><br><span class="line"><span class="comment"># load</span></span><br><span class="line">obs_render = np.load(<span class="string">'obs_render.npy'</span>,  allow_pickle=<span class="literal">True</span>)</span><br><span class="line">obs_list = np.load(<span class="string">'obs_list.npy'</span>, allow_pickle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>保存txt</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save</span></span><br><span class="line">txt = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">np.savetxt(<span class="string">'test.txt'</span>, txt)</span><br><span class="line"><span class="comment"># load</span></span><br><span class="line">np.loadtxt(<span class="string">'test.txt'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="squeeze-函数"><a href="#squeeze-函数" class="headerlink" title="squeeze()函数"></a><strong>squeeze()函数</strong></h3><p>函数原型：<code>numpy.squeeze(a, axis=None)</code><br>函数功能：把数组中shape中为1的维度去掉。默认删除a数组中所有shape中为1的维度，axis指定要删除的维度，axis=0表示第0维，若是该维度的shape不为1，则会报错。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [ [[<span class="number">1</span>,<span class="number">2</span>]], [[<span class="number">3</span>,<span class="number">4</span>]] ]    <span class="comment"># shape为2*1*2</span></span><br><span class="line"><span class="comment"># 删除中间为1的维度后</span></span><br><span class="line">a = [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>] ]  <span class="comment"># 看起来就像是将“穿”的夹层多余的衣服（括号）脱掉一层</span></span><br></pre></td></tr></table></figure>
<p>我们会在PyTorch中使用使用squeeze()和unsqueeze()进行降维和升维的步骤。</p>
<p>unsqueeze()函数的功能是在tensor的某个维度上添加一个维数为1的维度，这个功能用view()函数也可以实现。这一功能尤其在神经网络输入单个样本时很有用，由于pytorch神经网络要求的输入都是mini-batch型的，维度为[batch_size, channels, w, h]，而一个样本的维度为[c, w, h]，此时用unsqueeze()增加一个维度变为[1, c, w, h]就很方便了。</p>
<h3 id="median"><a href="#median" class="headerlink" title="median()"></a><strong>median()</strong></h3><blockquote>
<p>edian(a,<br>    <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=axis&amp;spm=1001.2101.3001.7020">axis</a>=None,<br>    out=None,<br>    overwrite_input=False,<br>    keepdims=False)</p>
<p><strong>a：</strong>输入的数组；<br><strong>axis：</strong>计算哪个轴上的均值，比如输入是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=二维数组&amp;spm=1001.2101.3001.7020">二维数组</a>，那么axis=0对应行，axis=1对应列；<br><strong>out：</strong>用于放置求取中位数后的数组。 它必须具有与预期输出相同的形状和缓冲区长度；<br><strong>overwrite_input :</strong>一个bool型的参数，默认为Flase。如果为True那么将直接在数组内存中计算，这意味着计算之后原数组没办法保存，但是好处在于节省内存资源，Flase则相反；<br><strong>keepdims：</strong>一个bool型的参数，默认为Flase。如果为True那么求取中位数的那个轴将保留在结果中；</p>
</blockquote>
<p>计算沿指定轴的均值,返回数组元素的均值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">10</span>,  <span class="number">7</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.median(a)</span><br><span class="line"><span class="number">3.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.median(a, axis=<span class="number">0</span>)</span><br><span class="line">array([ <span class="number">6.5</span>,  <span class="number">4.5</span>,  <span class="number">2.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.median(a, axis=<span class="number">1</span>)</span><br><span class="line">array([ <span class="number">7.</span>,  <span class="number">2.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = np.median(a, axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>out = np.zeros_like(m)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.median(a, axis=<span class="number">0</span>, out=m)</span><br><span class="line">array([ <span class="number">6.5</span>,  <span class="number">4.5</span>,  <span class="number">2.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">array([ <span class="number">6.5</span>,  <span class="number">4.5</span>,  <span class="number">2.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.median(b, axis=<span class="number">1</span>, overwrite_input=<span class="literal">True</span>)</span><br><span class="line">array([ <span class="number">7.</span>,  <span class="number">2.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="keyword">not</span> np.<span class="built_in">all</span>(a==b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.median(b, axis=<span class="literal">None</span>, overwrite_input=<span class="literal">True</span>)</span><br><span class="line"><span class="number">3.5</span></span><br></pre></td></tr></table></figure>
<h3 id="expand-dims"><a href="#expand-dims" class="headerlink" title="expand_dims()"></a><strong>expand_dims()</strong></h3><p>这个东西的主要作用，就是增加一个维度。</p>
<p>现在我们假设有一个数组A，数组A是一个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=两行三列&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A377793892}">两行三列</a>的矩阵。大小我们记成（2,3）。</p>
<p>先明白一个常识，计算机中计数，一般是从0开始的。</p>
<p>所以（2,3）这个两行三列的矩阵，</p>
<p>它的第“0”维，就是这个“2”行；第“1”维，就是这个“3”列。</p>
<p>这个函数的作用，就是在第“axis”维，加一个维度出来，原先的“维”，推到右边去。</p>
<p>比如我们设置axis为0，那[A矩阵]的大小就变成了（1,2,3），就从2*3的二维矩阵变成了一个1*2*3的三维矩阵。如果设置[axis]为1，矩阵大小就变成了（2,1,3），变成了一个2*1*3的三维矩阵。axis为2的时候，就变成（2,3,1)啦。</p>
<p>那么，说了这么多，矩阵的形式变了，那么矩阵里面的数字怎么变的呢？</p>
<p>举个例子：</p>
<p>假设现在矩阵是2*3的矩阵，六个数字</p>
<p>1 2 3</p>
<p>4 5 6</p>
<p>初中和高中所学的平面直角坐标系和空间直角坐标系还记得吗？</p>
<p>我们设置axis为0，矩阵从2*3的二维矩阵变成了1*2*3的三维矩阵。</p>
<p>我们假设原来是一个二维平面，横坐标为x，纵坐标为y, 2*3的矩阵在这个XOY平面上。此时就是一个二维矩阵，（根本就没有z轴）</p>
<p>而变换以后，现在变成了三维矩阵，变成了一个空间直角坐标系，，有x，y，z三个轴。</p>
<p>原先的2*3的矩阵从XOY平面移动到了YOZ平面</p>
<p>（我们把原先的矩阵当成一个平摊在桌面上的纸片，变换以后，相当于给它立起来了），然后原先的X轴的“厚度”为1，此时虽然形式还是原来的数字，但是多了一个轴。</p>
<p>那如果设置axis为1呢？</p>
<p>就是从XOY面的矩阵，给它立起来到XOZ平面，在Y轴的厚度为1。</p>
<p>设置axis为2，就是从XOY面的矩阵，还是放在XOY面上。但是这时候多了一个z轴，（相当于这个操作之后可以在桌面的纸片上面，叠加新的纸片了）</p>
<p>——————————————————————————————————</p>
<p>这时候我们再看矩阵</p>
<p>1 2 3</p>
<p>4 5 6</p>
<p>原先A[0][0]对应1,A[0][1]对应2,A[0][2]对应3,A[1][0]对应4……</p>
<p>如果设置axis为0，这时候矩阵从XOY平面移动到了YOZ平面，X轴只有一个值</p>
<p>那么,变换后的矩阵A’的第一个维度，只有一个值，就只能是0</p>
<p>A’[0][0][0]是1，A[0][0][1]是2，A[0][0][2]是3</p>
<p>A’[0][1][0]是4，A[0][1][1]是5，A[0][1][2]是6</p>
<p>A’[0][0]不指定第三维，那么就是[1,2,3]</p>
<p>A’[0][1]不指定第三维，就是[4,5,6]</p>
<p>那A[1][0][0]……呢？不好意思，没有，因为第一维只能取一个数，就是0。</p>
<p>axis为1,2都同理。</p>
<p>可能说的有点啰嗦了。</p>
<p>如果是三维矩阵变成四维矩阵，那就不好直接想象样子了。但是道理是一样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">122</span>,<span class="number">34</span>,<span class="number">45</span>])</span><br><span class="line">b = np.expand_dims(a,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[122  34  45]]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">b = np.expand_dims(a,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[122]</span></span><br><span class="line"><span class="string"> [ 34]</span></span><br><span class="line"><span class="string"> [ 45]]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">b = np.expand_dims(a,-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[122]</span></span><br><span class="line"><span class="string"> [ 34]</span></span><br><span class="line"><span class="string"> [ 45]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h3 id="np-linalg"><a href="#np-linalg" class="headerlink" title="np.linalg"></a>np.linalg</h3><p><code>np.linalg</code> 是 NumPy 库中提供的线性代数模块，用于进行线性代数运算。该模块提供了许多用于矩阵和向量操作的函数，包括求解线性方程组、计算矩阵的逆、计算特征值和特征向量等。</p>
<p>以下是一些常用的 <code>np.linalg</code> 函数：</p>
<ul>
<li><code>np.linalg.inv()</code>：计算矩阵的逆。</li>
<li><code>np.linalg.det()</code>：计算矩阵的行列式。</li>
<li><code>np.linalg.eig()</code>：计算矩阵的特征值和特征向量。</li>
<li><code>np.linalg.solve()</code>：解线性方程组。</li>
<li><code>np.linalg.norm()</code>：计算向量或矩阵的范数。</li>
<li><code>np.linalg.svd()</code>：进行奇异值分解。</li>
</ul>
<p>这些函数可以帮助我们进行各种线性代数的计算和操作。</p>
<h4 id="np-linalg-norm"><a href="#np-linalg-norm" class="headerlink" title="np.linalg.norm"></a>np.linalg.norm</h4><p><code>np.linalg.norm(self.bs_pos[i] - self.bs_pos[j])</code> 是用来计算两个向量之间的欧氏距离。具体而言，它计算了 <code>self.bs_pos[i]</code> 和 <code>self.bs_pos[j]</code> 之间的欧氏距离。</p>
<p>这里假设 <code>self.bs_pos</code> 是一个二维数组，其中每一行表示一个向量。<code>self.bs_pos[i]</code> 表示第 i 行向量，<code>self.bs_pos[j]</code> 表示第 j 行向量。<code>np.linalg.norm()</code> 函数将两个向量相减得到一个差向量，然后计算该差向量的欧氏范数，即两个向量之间的欧氏距离。</p>
<p>注意，<code>np.linalg.norm()</code> 的结果是一个标量值，表示两个向量之间的距离大小。</p>
<p>假设有两个二维向量 <code>v1</code> 和 <code>v2</code>，可以使用 <code>np.linalg.norm()</code> 来计算它们之间的欧氏距离。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">v1 = np.array([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">v2 = np.array([<span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">distance = np.linalg.norm(v1 - v2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(distance)</span><br><span class="line"><span class="comment">#5.0</span></span><br></pre></td></tr></table></figure>
<p>这里，<code>v1</code> 和 <code>v2</code> 分别表示两个二维向量 <code>[1, 2]</code> 和 <code>[4, 6]</code>。通过计算它们之间的欧氏距离，得到的结果为 <code>5.0</code>。</p>
<h3 id="random"><a href="#random" class="headerlink" title="random"></a><strong>random</strong></h3><p><code>seed()</code></p>
<p>可以通过输入int或arrat_like来使得随机的结果固定;使实验可重复，对于同一个seed，生成的随机数相同</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.seed(seed=<span class="literal">None</span>) </span><br></pre></td></tr></table></figure>
<h4 id="random-1"><a href="#random-1" class="headerlink" title="random()"></a><code>random()</code></h4><p>生成指定维度的[0,1)间的随机数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e = np.random.random((<span class="number">2</span>,<span class="number">2</span>)) <span class="comment"># Create an array filled with random values</span></span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[0.44790028 0.50508009]</span></span><br><span class="line"><span class="string"> [0.99214661 0.3657341 ]]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="random-sample"><a href="#random-sample" class="headerlink" title="random_sample()"></a><code>random_sample()</code></h4><p>用于在numpy中进行随机采样的函数之一。它返回指定形状的数组，并在半开间隔中将其填充为随机浮点数<code>[0.0, 1.0).</code></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用法： numpy.random.random_sample(size=None)</span><br></pre></td></tr></table></figure>
<h4 id="rand-d0-d1…dn"><a href="#rand-d0-d1…dn" class="headerlink" title="`rand(d0,d1…dn)"></a>`rand(d0,d1…dn)</h4><p>`</p>
<p>通过本函数可以返回一个或一组服从“0~1”均匀分布的随机样本值。随机样本取值范围是[0,1)，不包括1。  应用：在深度学习的Dropout正则化方法中，可以用于生成dropout随机向量（dl），例如（keep_prob表示保留神经元的比例）：</p>
<blockquote>
<p>dl = np.random.rand(al.shape[0],al.shape[1]) &lt; keep_prob</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.rand(<span class="number">4</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>out:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([[0.27388623, 0.26940718, 0.13914399],</span><br><span class="line">       [0.79281929, 0.82086991, 0.18488757],</span><br><span class="line">       [0.09359689, 0.08408097, 0.36463413],</span><br><span class="line">       [0.02924776, 0.81743324, 0.26361082]])</span><br></pre></td></tr></table></figure>
<h4 id="randn"><a href="#randn" class="headerlink" title="randn()"></a><code>randn()</code></h4><p>randn函数返回一个或一组样本，具有[标准正态分布]。</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202210071645201.png" alt="image-20221007164533110"></p>
<h4 id="numpy-random-randint-low-high-None-size-None-dtype-’l’"><a href="#numpy-random-randint-low-high-None-size-None-dtype-’l’" class="headerlink" title="numpy.random.randint(low, high=None, size=None, dtype=’l’)"></a><code>numpy.random.randint(low, high=None, size=None, dtype=’l’)</code></h4><ul>
<li>从区间[low,high）返回随机整数</li>
<li>参数：low为最小值，high为最大值，size为数组维度大小，dtype为数据类型，默认的数据类型是np.int</li>
<li>high没有填写时，默认生成随机数的范围是[0，low)</li>
</ul>
<h4 id="np-random-normal-mu-sigma-size"><a href="#np-random-normal-mu-sigma-size" class="headerlink" title="np.random.normal(mu, sigma, size)"></a><code>np.random.normal(mu, sigma, size)</code></h4><p>随机生成服从正太分布的随机数。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.489ex;" xmlns="http://www.w3.org/2000/svg" width="1.364ex" height="1.489ex" role="img" focusable="false" viewBox="0 -442 603 658"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D707" d="M58 -216Q44 -216 34 -208T23 -186Q23 -176 96 116T173 414Q186 442 219 442Q231 441 239 435T249 423T251 413Q251 401 220 279T187 142Q185 131 185 107V99Q185 26 252 26Q261 26 270 27T287 31T302 38T315 45T327 55T338 65T348 77T356 88T365 100L372 110L408 253Q444 395 448 404Q461 431 491 431Q504 431 512 424T523 412T525 402L449 84Q448 79 448 68Q448 43 455 35T476 26Q485 27 496 35Q517 55 537 131Q543 151 547 152Q549 153 557 153H561Q580 153 580 144Q580 138 575 117T555 63T523 13Q510 0 491 -8Q483 -10 467 -10Q446 -10 429 -4T402 11T385 29T376 44T374 51L368 45Q362 39 350 30T324 12T288 -4T246 -11Q199 -11 153 12L129 -85Q108 -167 104 -180T92 -202Q76 -216 58 -216Z"></path></g></g></g></svg></mjx-container>为均值</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.292ex" height="1ex" role="img" focusable="false" viewBox="0 -431 571 442"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g></g></g></svg></mjx-container>为标准差</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.948ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 1745 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(469,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(814,0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g><g data-mml-node="mi" transform="translate(1279,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g></g></g></svg></mjx-container>: int or tuple of ints, optional。输出形状。如果给定的形状是，例如，(m, n, k)，那么将绘制m x n x k的样本。默认为无，在这种情况下，将返回一个单一的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">作者：采石工</span></span><br><span class="line"><span class="string">来源：知乎</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> cholesky</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">sampleNo = <span class="number">1000</span>;</span><br><span class="line"><span class="comment"># 一维正态分布</span></span><br><span class="line"><span class="comment"># 下面三种方式是等效的</span></span><br><span class="line">mu = <span class="number">3</span></span><br><span class="line">sigma = <span class="number">0.1</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">s = np.random.normal(mu, sigma, sampleNo )</span><br><span class="line">plt.subplot(<span class="number">141</span>)</span><br><span class="line">plt.hist(s, <span class="number">30</span>, normed=<span class="literal">True</span>)</span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">s = sigma * np.random.randn(sampleNo ) + mu</span><br><span class="line">plt.subplot(<span class="number">142</span>)</span><br><span class="line">plt.hist(s, <span class="number">30</span>, normed=<span class="literal">True</span>)</span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">s = sigma * np.random.standard_normal(sampleNo ) + mu</span><br><span class="line">plt.subplot(<span class="number">143</span>)</span><br><span class="line">plt.hist(s, <span class="number">30</span>, normed=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 二维正态分布</span></span><br><span class="line">mu = np.array([[<span class="number">1</span>, <span class="number">5</span>]])</span><br><span class="line">Sigma = np.array([[<span class="number">1</span>, <span class="number">0.5</span>], [<span class="number">1.5</span>, <span class="number">3</span>]])</span><br><span class="line">R = cholesky(Sigma)</span><br><span class="line">s = np.dot(np.random.randn(sampleNo, <span class="number">2</span>), R) + mu</span><br><span class="line">plt.subplot(<span class="number">144</span>)</span><br><span class="line"><span class="comment"># 注意绘制的是散点图，而不是直方图</span></span><br><span class="line">plt.plot(s[:,<span class="number">0</span>],s[:,<span class="number">1</span>],<span class="string">'+'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="choice-a-size-None-replace-True-p-None"><a href="#choice-a-size-None-replace-True-p-None" class="headerlink" title="choice(a, size=None, replace=True, p=None)"></a><code>choice(a, size=None, replace=True, p=None)</code></h4><ul>
<li>从给定的一位数组中生成一个随机样本</li>
<li>a要求输入一维数组类似数据或者是一个int；size是生成的数组纬度，要求数字或元组；replace为布尔型，决定样本是否有替换；p为样本出现概率</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">///p是一个<span class="built_in">list</span>,p的size 必须与a的size一致，p中每个元素对应了a中每个元素被选择的概率</span><br><span class="line">np.random.choice(list_tmp,size = (<span class="number">3</span>,<span class="number">3</span>),p = [<span class="number">0.1</span>,<span class="number">0.6</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="shuffle-x"><a href="#shuffle-x" class="headerlink" title="shuffle(x)"></a><code>shuffle(x)</code></h4><p>现场修改序列，改变自身内容。（类似洗牌，打乱顺序）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; arr = np.arange(10)</span><br><span class="line">&gt;&gt;&gt; np.random.shuffle(arr)</span><br><span class="line">&gt;&gt;&gt; arr</span><br><span class="line">[1 7 5 2 9 4 3 6 0 8]</span><br></pre></td></tr></table></figure>
<h4 id="default-rng-myseed"><a href="#default-rng-myseed" class="headerlink" title="default_rng(myseed)"></a><code>default_rng(myseed)</code></h4><p>打乱数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myseed = <span class="number">42069</span></span><br><span class="line">rng = np.random.default_rng(myseed)</span><br><span class="line">df = pandas.read_csv(<span class="string">'iris.csv'</span>)</span><br><span class="line">data = np.array(df)</span><br><span class="line">rng.shuffle(data)</span><br></pre></td></tr></table></figure>
<h3 id="tile"><a href="#tile" class="headerlink" title="tile()"></a><strong>tile()</strong></h3><p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202209091649941.png" alt="image-20220909164953161" style="zoom: 50%;"></p>
<h3 id="std"><a href="#std" class="headerlink" title="std()"></a><strong>std()</strong></h3><p>计算标准差</p>
<p>因此，想要正确调用，必须使ddof=1：</p>
<p><code>ddof : int, optional</code><br>Means Delta Degrees of Freedom. The divisor used in calculations is N - ddof, where N represents the number of elements. By default ddof is zero.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.std([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], ddof=<span class="number">1</span>)</span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<h3 id="广播（broadcasting）"><a href="#广播（broadcasting）" class="headerlink" title="广播（broadcasting）"></a><strong>广播（broadcasting）</strong></h3><p>在Numpy中，如果参与运算的两个数组或者矩阵的形状不同，则解释器将双方的各个维数右对齐，并开始从右至左依次比较对应的两个维数是否相等。如果只存在<code>“相等“</code>、<code>”不相等但有一方为1“</code>，<code>”有一方没有对应的维数</code>“这三种情况，则进行广播，否则报错。</p>
<p>例如，一方的维数为6x3x5,另一方的维数是3x1，则进行广播，运算的结果为一个6x3x5大小的数组。再例如，一方为行向量，维数为1xm，另一方为标量b，维数为1x1，则进行广播，广播的结果是将标量b拉伸为与前一方形状相同的1xm维行向量，其中的元素都是标量b的副本，然后再进行运算。</p>
<h3 id="np-power-x1-x2"><a href="#np-power-x1-x2" class="headerlink" title="np.power(x1,x2)"></a><strong>np.power(x1,x2)</strong></h3><p>x1和x2可以是整数类型或数组或者array类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x1 = np.array([[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line">x2 = np.array([[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">result = np.power(x1,x2) <span class="comment"># 实际就是相应位置的前者的后者次方(x1[i,j]**x2[i,j])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[  0   1]</span></span><br><span class="line"><span class="string"> [ 16 243]]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h3 id="numpy-where—将条件逻辑表述为数组运算"><a href="#numpy-where—将条件逻辑表述为数组运算" class="headerlink" title="numpy.where—将条件逻辑表述为数组运算"></a><strong>numpy.where—将条件逻辑表述为数组运算</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = np.where(cond, xarr, yarr)</span><br></pre></td></tr></table></figure>
<p>np.where的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，where通常用于根据另一个数组而产生一个新的数组。假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利用np.where，则会非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">172</span>]: arr = np.random.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: arr</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line">array([[-<span class="number">0.5031</span>, -<span class="number">0.6223</span>, -<span class="number">0.9212</span>, -<span class="number">0.7262</span>],</span><br><span class="line">       [ <span class="number">0.2229</span>,  <span class="number">0.0513</span>, -<span class="number">1.1577</span>,  <span class="number">0.8167</span>],</span><br><span class="line">       [ <span class="number">0.4336</span>,  <span class="number">1.0107</span>,  <span class="number">1.8249</span>, -<span class="number">0.9975</span>],</span><br><span class="line">       [ <span class="number">0.8506</span>, -<span class="number">0.1316</span>,  <span class="number">0.9124</span>,  <span class="number">0.1882</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">174</span>]: arr &gt; <span class="number">0</span></span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">175</span>]: np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, -<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">175</span>]: </span><br><span class="line">array([[-<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">2</span>, -<span class="number">2</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>, -<span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>, -<span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>使用np.where，可以将标量和数组结合起来。例如，我可用常数2替换arr中所有正的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">176</span>]: np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, arr) <span class="comment"># set only positive values to 2</span></span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">array([[-<span class="number">0.5031</span>, -<span class="number">0.6223</span>, -<span class="number">0.9212</span>, -<span class="number">0.7262</span>],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.</span>    , -<span class="number">1.1577</span>,  <span class="number">2.</span>    ],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.</span>    ,  <span class="number">2.</span>    , -<span class="number">0.9975</span>],</span><br><span class="line">       [ <span class="number">2.</span>    , -<span class="number">0.1316</span>,  <span class="number">2.</span>    ,  <span class="number">2.</span>    ]])</span><br></pre></td></tr></table></figure>
<h3 id="np-mgrid-np-ravel-np-c"><a href="#np-mgrid-np-ravel-np-c" class="headerlink" title="np.mgrid[] np.ravel np.c_[]"></a><code>np.mgrid[] np.ravel np.c_[]</code></h3><p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072329710.png" alt="image-20230107232903557"></p>
<p>数据数组去除第一行和第一列data = np.array(data[1:])[:, 1:]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'*******************************'</span>)</span><br><span class="line">data1 = np.array(data[<span class="number">1</span>:])[:, <span class="number">1</span>:].astype(<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(data1)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202204081710167.png" alt="image-20220408170941407" style="zoom:50%;"></p>
<h3 id="np-fromstring"><a href="#np-fromstring" class="headerlink" title="np.fromstring"></a><strong>np.fromstring</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    TARGET_PHRASE = <span class="string">'You get it!'</span>  </span><br><span class="line">    TARGET_ASCII = np.fromstring(TARGET_PHRASE, dtype=np.uint8)  <span class="comment"># convert string to number</span></span><br><span class="line">    <span class="built_in">print</span>(TARGET_PHRASE,TARGET_ASCII)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(TARGET_PHRASE),TARGET_ASCII.shape)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">You get it! [ 89 111 117  32 103 101 116  32 105 116  33]</span></span><br><span class="line"><span class="string">11 (11,)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>不过这个方法现在已经过时了，现在常用<code>numpy.frombuffer</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    TARGET_PHRASE = <span class="string">'You get it!'</span>  <span class="comment"># target DNA</span></span><br><span class="line">    TARGET_ASCII = np.frombuffer(TARGET_PHRASE.encode() ,dtype=np.uint8)  <span class="comment"># convert string to number</span></span><br><span class="line">    <span class="built_in">print</span>(TARGET_PHRASE,TARGET_ASCII)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(TARGET_PHRASE),TARGET_ASCII.shape)</span><br><span class="line">    s = TARGET_ASCII.tobytes() .decode(<span class="string">'ascii'</span>)</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    You get it! [ 89 111 117  32 103 101 116  32 105 116  33]</span></span><br><span class="line"><span class="string">	11 (11,)</span></span><br><span class="line"><span class="string">	You get it!</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure>
<h3 id="np-vstack"><a href="#np-vstack" class="headerlink" title="np.vstack()"></a><strong>np.vstack()</strong></h3><p>按垂直方向（行顺序）堆叠数组构成一个新的数组<br>堆叠的数组需要具有相同的维度</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202303172134840.png" alt="image-20230317213456779"></p>
<h3 id="np-hstack"><a href="#np-hstack" class="headerlink" title="np.hstack()"></a><strong>np.hstack()</strong></h3><p>按水平方向（列顺序）堆叠数组构成一个新的数组<br>堆叠的数组需要具有相同的维度</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202303172134559.png" alt="image-20230317213435493"></p>
<h3 id="np-argsort"><a href="#np-argsort" class="headerlink" title="np.argsort()"></a><strong>np.argsort()</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.argsort(a, axis=-<span class="number">1</span>, kind=<span class="string">'quicksort'</span>, order=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>函数功能：将a中的元素从小到大排列，提取其在排列前对应的index(索引)输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x=np.array([<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,-<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>])</span><br><span class="line">y=np.argsort(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'一维数组的排序结果：{}'</span>.<span class="built_in">format</span>(y))</span><br><span class="line"><span class="comment">#一维数组的排序结果：[3 0 2 1 4 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="numpy之dtype、type以及astype的用法"><a href="#numpy之dtype、type以及astype的用法" class="headerlink" title="numpy之dtype、type以及astype的用法"></a>numpy之dtype、type以及astype的用法</h3><p>1、type 获取数据类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">type</span>(a)</span><br></pre></td></tr></table></figure>
<p>2、dtype 获取<strong>数组</strong>元素的类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b=np.array(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="built_in">print</span>(b.dtype)</span><br><span class="line"><span class="built_in">print</span>(a.dtype)</span><br></pre></td></tr></table></figure>
<p>注意：只有数组可用dtype,list不可用</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202304132159026.webp" alt="img"></p>
<p>3、astype 修改<em>数组</em>的数据类型</p>
<p>int32—&gt;float64<br>float64—&gt;int32<br>string—&gt;float64<br>注意：int32、float64是Numpy库自己的一套数据类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c=[<span class="number">0.11</span>,<span class="number">0.22</span>,<span class="number">0.33</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c))</span><br><span class="line">e=np.array(c)</span><br><span class="line">d=e.astype(np.<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<h3 id="savetxt"><a href="#savetxt" class="headerlink" title="savetxt()"></a>savetxt()</h3><p>数据可以是浮点型、整型或者字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">savetxt</span>(<span class="params">fname, X, fmt=<span class="string">'%.18e'</span>, delimiter=<span class="string">' '</span>, newline=<span class="string">'\n'</span>, header=<span class="string">''</span>,</span></span><br><span class="line"><span class="params">            footer=<span class="string">''</span>, comments=<span class="string">'# '</span>, encoding=<span class="literal">None</span></span>):</span><br></pre></td></tr></table></figure>
<p>X : 要保存的数据</p>
<p>fmt : 保存的格式</p>
<p>delimiter : 每列的填充字符</p>
<p>输出为整数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  numpy <span class="keyword">as</span> np</span><br><span class="line">data=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">np.savetxt(<span class="string">"./demo1"</span>,data,fmt=<span class="string">"%d"</span>,delimiter=<span class="string">" "</span>) <span class="comment">#输出为整数 %d表示整数</span></span><br></pre></td></tr></table></figure>
<p>输出为科学计数法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  numpy <span class="keyword">as</span> np</span><br><span class="line">data=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">np.savetxt(<span class="string">"./demo1"</span>,data,fmt=<span class="string">"%.10e"</span>,delimiter=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure>
<p>如果要每列保存不同的格式怎么办？比如像下面这样 前三列要保留小数点后4位小数 后三列保存位整数怎么办？</p>
<p>存储的txt文件中包含多列数据时，但这些对这些数据每列要求的格式并不统一</p>
<p>利用savetxt函数中的fmt参数可以设置格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  numpy <span class="keyword">as</span> np</span><br><span class="line">data=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">np.savetxt(<span class="string">"./demo1"</span>,data,fmt=<span class="string">"%.4f %3f %d"</span>,delimiter=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure>
<p>每列都可以通过fmt单独设置输出的精度</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202304141058026.png" alt="image-20230414105808973"></p>
<p>保存字符串数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#save</span></span><br><span class="line">np.savetxt(<span class="string">'importance_feature.txt'</span>,import_features,fmt=<span class="string">'%s'</span>)</span><br><span class="line"><span class="comment">#load</span></span><br><span class="line">features = np.loadtxt(<span class="string">'importance_feature.txt'</span>,dtype=np.str_)</span><br></pre></td></tr></table></figure>
<h3 id="set-printoptions-suppress-True"><a href="#set-printoptions-suppress-True" class="headerlink" title="set_printoptions(suppress=True)"></a>set_printoptions(suppress=True)</h3><p><code>np.set_printoptions(suppress=True)</code> 是 NumPy 库中的函数，用于设置打印数组时的显示选项。具体而言，<code>suppress=True</code> 参数的作用是禁止科学计数法，让 NumPy 数组以常规的方式显示。</p>
<p>默认情况下，当打印较大或较小的数字时，NumPy 会使用科学计数法来表示这些数字，以便更紧凑地显示。但在某些情况下，我们希望以常规的小数形式显示数组，而不是科学计数法。这时，可以使用 <code>np.set_printoptions(suppress=True)</code> 将科学计数法禁止，从而以常规形式显示数组中的数字。</p>
<p>以下是使用 <code>np.set_printoptions(suppress=True)</code> 的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个较小的数组</span></span><br><span class="line">arr = np.array([<span class="number">0.000123</span>, <span class="number">123456789</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数组，默认情况下使用科学计数法</span></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># 输出: [1.23000000e-04 1.23456789e+08]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置禁止科学计数法</span></span><br><span class="line">np.set_printoptions(suppress=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次打印数组，以常规形式显示</span></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># 输出: [       0. 123456789.]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过调用 <code>np.set_printoptions(suppress=True)</code>，我们可以在后续的打印语句中禁止科学计数法，从而以常规形式显示数组中的数字。这在需要更易读的数字表示时非常有用，特别是在处理小数值或大数值的情况下。</p>
<h3 id="concatenate"><a href="#concatenate" class="headerlink" title="concatenate"></a>concatenate</h3><p><code>np.concatenate</code> 是 NumPy 库中的函数，用于将多个数组沿指定轴连接起来。它的语法如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.concatenate((array1, array2, ...), axis=0)</span><br></pre></td></tr></table></figure>
<p>其中，<code>array1, array2, ...</code> 是要连接的多个数组，<code>axis</code> 是指定连接轴的参数（默认为 0）。在连接数组时，它们的形状在除连接轴以外的维度应保持一致。</p>
<p>例如，假设有两个一维数组 <code>a = [1, 2, 3]</code> 和 <code>b = [4, 5, 6]</code>，可以使用 <code>np.concatenate</code> 将它们连接成一个新的一维数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = np.concatenate((a, b))</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>如果要在不同轴上连接多维数组，可以通过指定 <code>axis</code> 参数来实现。例如，假设有两个二维数组 <code>arr1</code> 和 <code>arr2</code>，可以使用 <code>np.concatenate</code> 在行（轴 0）方向上连接它们：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = np.concatenate((arr1, arr2), axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>类似地，可以在列（轴 1）方向上连接它们：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = np.concatenate((arr1, arr2), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><code>np.concatenate</code> 可以在不同轴上连接任意多个数组，只要它们的维度兼容。</p>
<h3 id="reshape"><a href="#reshape" class="headerlink" title="reshape"></a>reshape</h3><p><code>np.reshape</code> 是 NumPy 库中的函数，用于改变数组的形状，使其符合指定的维度。它的语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.reshape(array, newshape, order=<span class="string">'C'</span>)</span><br></pre></td></tr></table></figure>
<p>其中，<code>array</code> 是要改变形状的数组，<code>newshape</code> 是指定的新形状，可以是一个整数或由整数构成的元组。<code>order</code> 参数是可选的，用于指定数组在内存中的存储顺序，默认为 <code>'C'</code>，表示按行优先顺序。</p>
<p>在你提供的代码中，<code>np.reshape(bs_pos1[1:5][:,0:2], -1)</code> 的作用是将 <code>bs_pos1</code> 数组的第 1 到 4 行（索引为 1:5）和第 1 到 2 列（索引为 0:2）的元素提取出来，并将其转换为一维数组。</p>
<p>具体而言，<code>bs_pos1[1:5][:,0:2]</code> 选择了 <code>bs_pos1</code> 数组的第 1 到 4 行和第 1 到 2 列的元素，然后 <code>np.reshape(..., -1)</code> 将其转换为一维数组。这样可以将原始的二维数组转换为一维，方便后续的连接操作。</p>
<p>请注意，<code>-1</code> 在 <code>np.reshape</code> 中的作用是根据数组的大小自动计算缺失的维度。在这种情况下，<code>-1</code> 表示根据已知的维度和元素个数自动计算缺失的维度，以使得数组的形状保持一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含 12 个元素的一维数组</span></span><br><span class="line">arr = np.arange(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一维数组转换为二维数组，形状为 (3, 4)</span></span><br><span class="line">reshaped_arr = np.reshape(arr, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(reshaped_arr)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[ 0  1  2  3]</span></span><br><span class="line"><span class="string"> [ 4  5  6  7]</span></span><br><span class="line"><span class="string"> [ 8  9 10 11]]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们首先创建了一个包含 12 个元素的一维数组 <code>arr</code>，然后使用 <code>np.reshape</code> 将其转换为一个形状为 (3, 4) 的二维数组 <code>reshaped_arr</code>。可以看到，<code>arr</code> 的元素在 <code>reshaped_arr</code> 中按照行优先的顺序重新排列。</p>
<p>需要注意的是，<code>np.reshape</code> 返回的是一个新的数组，原始数组 <code>arr</code> 并没有被改变。</p>
<h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><p><code>小技巧：</code></p>
<p>Jupyter Notebook 上面用 Matplotlib 了，但是不知道大家看到画出来那一坨糊糊的东西会不会跟我一样浑身难受。实际上，只要多加一行配置，就能够让 Matplotlib 在 Jupyter Notebook 上面输出矢量图了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format = <span class="string">'svg'</span></span><br></pre></td></tr></table></figure>
<p>savefig 只要指定文件名后缀是 .pdf 或者 .eps 就能生成能方便地插入 latex 的图片了！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">'tmp.pdf'</span>, bbox_inches=<span class="string">'tight'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><code>matplotlib实用函数</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib_inline <span class="keyword">import</span> backend_inline</span><br><span class="line"><span class="keyword">from</span> IPython <span class="keyword">import</span> display</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">use_svg_display</span>():  </span><br><span class="line">    <span class="string">"""使用svg格式在Jupyter中显示绘图"""</span></span><br><span class="line">    backend_inline.set_matplotlib_formats(<span class="string">'svg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_figsize</span>(<span class="params">figsize=(<span class="params"><span class="number">3.5</span>, <span class="number">2.5</span></span>)</span>):  </span><br><span class="line">    <span class="string">"""设置matplotlib的图表大小"""</span></span><br><span class="line">    use_svg_display()</span><br><span class="line">    plt.rcParams[<span class="string">'figure.figsize'</span>] = figsize</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_axes</span>(<span class="params">axes, xlabel, ylabel, xlim, ylim, xscale, yscale, legend</span>):</span><br><span class="line">    <span class="string">"""设置matplotlib的轴"""</span></span><br><span class="line">    axes.set_xlabel(xlabel)</span><br><span class="line">    axes.set_ylabel(ylabel)</span><br><span class="line">    axes.set_xscale(xscale)</span><br><span class="line">    axes.set_yscale(yscale)</span><br><span class="line">    axes.set_xlim(xlim)</span><br><span class="line">    axes.set_ylim(ylim)</span><br><span class="line">    <span class="keyword">if</span> legend:</span><br><span class="line">        axes.legend(legend)</span><br><span class="line">    axes.grid()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot</span>(<span class="params">X, Y=<span class="literal">None</span>, xlabel=<span class="literal">None</span>, ylabel=<span class="literal">None</span>, legend=<span class="literal">None</span>, xlim=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">         ylim=<span class="literal">None</span>, xscale=<span class="string">'linear'</span>, yscale=<span class="string">'linear'</span>,</span></span><br><span class="line"><span class="params">         fmts=(<span class="params"><span class="string">'-'</span>, <span class="string">'m--'</span>, <span class="string">'g-.'</span>, <span class="string">'r:'</span></span>), figsize=(<span class="params"><span class="number">3.5</span>, <span class="number">2.5</span></span>), axes=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">"""绘制数据点"""</span></span><br><span class="line">    <span class="keyword">if</span> legend <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        legend = []</span><br><span class="line"></span><br><span class="line">    set_figsize(figsize)</span><br><span class="line">    axes = axes <span class="keyword">if</span> axes <span class="keyword">else</span> plt.gca()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_one_axis</span>(<span class="params">X</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">hasattr</span>(X, <span class="string">"ndim"</span>) <span class="keyword">and</span> X.ndim == <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(X, <span class="built_in">list</span>)</span><br><span class="line">                <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(X[<span class="number">0</span>], <span class="string">"__len__"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> has_one_axis(X):</span><br><span class="line">        X = [X]</span><br><span class="line">    <span class="keyword">if</span> Y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        X, Y = [[]] * <span class="built_in">len</span>(X), X</span><br><span class="line">    <span class="keyword">elif</span> has_one_axis(Y):</span><br><span class="line">        Y = [Y]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(X) != <span class="built_in">len</span>(Y):</span><br><span class="line">        X = X * <span class="built_in">len</span>(Y)</span><br><span class="line">    axes.cla()</span><br><span class="line">    <span class="keyword">for</span> x, y, fmt <span class="keyword">in</span> <span class="built_in">zip</span>(X, Y, fmts):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(x):</span><br><span class="line">            axes.plot(x, y, fmt)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            axes.plot(y, fmt)</span><br><span class="line">    set_axes(axes, xlabel, ylabel, xlim, ylim, xscale, yscale, legend)</span><br></pre></td></tr></table></figure>
<p><code>使用上述函数画图</code></p>
<p>eg.1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * x ** <span class="number">2</span> - <span class="number">4</span> * x</span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0.1</span>)</span><br><span class="line">plot(x, [f(x), <span class="number">2</span> * x - <span class="number">3</span>], <span class="string">'x'</span>, <span class="string">'f(x)'</span>, legend=[<span class="string">'f(x)'</span>, <span class="string">'Tangent line (x=1)'</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301312154501.png" alt="image-20230131215451447"></p>
<p>eg.2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(-<span class="number">8.0</span>, <span class="number">8.0</span>, <span class="number">0.1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = torch.relu(x)</span><br><span class="line">d2l.plot(x.detach(), y.detach(), <span class="string">'x'</span>, <span class="string">'relu(x)'</span>, figsize=(<span class="number">5</span>, <span class="number">2.5</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202302041555105.png" alt="image-20230204155537022"></p>
<p>eg.3</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw</span>():</span><br><span class="line">    loss_list = np.loadtxt(<span class="string">"loss.txt"</span>)</span><br><span class="line">    accuracy_list = np.loadtxt(<span class="string">"accuracy.txt"</span>)</span><br><span class="line">    x = np.arange(<span class="built_in">len</span>(loss_list))</span><br><span class="line">    plot(x,[loss_list,accuracy_list],<span class="string">'step'</span>,<span class="string">''</span>,legend=[<span class="string">'loss'</span>, <span class="string">'accuracy'</span>],fmts=(<span class="string">'-'</span>, <span class="string">'-'</span>))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    draw()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34498545/article/details/112631706">改变刻度</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> xticks,yticks,np</span><br><span class="line"></span><br><span class="line">yticks(np.linspace(<span class="number">0</span>,<span class="number">1.</span>,<span class="number">11</span>,endpoint=<span class="literal">True</span>))</span><br><span class="line">plt.xlabel(<span class="string">"epoch"</span>)  <span class="comment"># x的轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">"accuracy"</span>)  <span class="comment"># y的轴标签</span></span><br><span class="line">plt.legend([<span class="string">"准确率"</span>])  <span class="comment"># 图例名称</span></span><br><span class="line">plt.title(<span class="string">"The Image Of Multinomial Logistic Regression"</span>)<span class="comment"># 图像名称</span></span><br><span class="line">plt.show()</span><br><span class="line">plt.plot()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202210130042736.png" alt="image-20221013004212618"></p>
<p>绘制两条简单的曲线</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the points using matplotlib</span></span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.xlabel(<span class="string">'x axis label'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y axis label'</span>)</span><br><span class="line">plt.title(<span class="string">'Sine and Cosine'</span>)</span><br><span class="line">plt.legend([<span class="string">'Sine'</span>, <span class="string">'Cosine'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义刻度</span></span><br><span class="line"><span class="comment">#x_list = [i for i in range(-10,11)]</span></span><br><span class="line"><span class="comment">#plt.xticks(x_list)</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202209091705736.png" alt="image-20220909170526666" style="zoom: 67%;"></p>
<p>绘制 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="19.817ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 8759 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1511,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2177.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(3233.6,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="msup" transform="translate(3733.6,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(605,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(4964.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(5964.6,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mi" transform="translate(6464.6,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(7258.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(8259,0)"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"></path></g></g></g></svg></mjx-container>的图像</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">8</span>)  <span class="comment"># x取值范围</span></span><br><span class="line">y = <span class="number">3</span> * x ** <span class="number">2</span> + <span class="number">7</span> * x - <span class="number">9</span>  <span class="comment"># y函数</span></span><br><span class="line">plt.plot(x, y, )  <span class="comment"># 以x为取值范围标定横坐标，y为纵坐标</span></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]  <span class="comment"># 解析中文字体</span></span><br><span class="line">plt.xlabel(<span class="string">"x的取值"</span>)  <span class="comment"># x的轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">"y的值"</span>)  <span class="comment"># y的轴标签</span></span><br><span class="line">plt.text(<span class="number">7</span>, <span class="number">100</span>, <span class="string">"我是曲线"</span>)  <span class="comment"># 曲线名称（标定位置）</span></span><br><span class="line">plt.legend([<span class="string">"我是图例"</span>])  <span class="comment"># 图例名称</span></span><br><span class="line">plt.title(<span class="string">"the image of function"</span>)<span class="comment"># 图像名称</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202209141238648.png" alt="image-20220914123822579"></p>
<p>绘制学习曲线</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_learning_curve</span>(<span class="params">loss_record, title=<span class="string">''</span></span>):</span><br><span class="line">    <span class="string">''' Plot learning curve of your DNN (train &amp; dev loss) '''</span></span><br><span class="line">    total_steps = <span class="built_in">len</span>(loss_record[<span class="string">'train'</span>])</span><br><span class="line">    x_1 = <span class="built_in">range</span>(total_steps) <span class="comment"># train曲线 x点集范围</span></span><br><span class="line">    x_2 = x_1[::<span class="built_in">len</span>(loss_record[<span class="string">'train'</span>]) // <span class="built_in">len</span>(loss_record[<span class="string">'dev'</span>])] <span class="comment"># dev曲线 x点集范围 </span></span><br><span class="line">    figure(figsize=(<span class="number">6</span>, <span class="number">4</span>)) <span class="comment"># 图像大小</span></span><br><span class="line">    plt.plot(x_1, loss_record[<span class="string">'train'</span>], c=<span class="string">'tab:red'</span>, label=<span class="string">'train'</span>) <span class="comment"># 绘制train曲线</span></span><br><span class="line">    plt.plot(x_2, loss_record[<span class="string">'dev'</span>], c=<span class="string">'tab:cyan'</span>, label=<span class="string">'dev'</span>)<span class="comment"># 绘制dev曲线</span></span><br><span class="line">    plt.ylim(<span class="number">0.0</span>, <span class="number">5.</span>) <span class="comment"># 限制 y轴取值范围</span></span><br><span class="line">    plt.xlabel(<span class="string">'Training steps'</span>)<span class="comment"># x轴名称</span></span><br><span class="line">    plt.ylabel(<span class="string">'MSE loss'</span>)<span class="comment"># y轴名称</span></span><br><span class="line">    plt.title(<span class="string">'Learning curve of {}'</span>.<span class="built_in">format</span>(title))<span class="comment"># 图标题</span></span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202209070946142.png" alt="image-20220907094610100"></p>
<p>绘制预测曲线拟合程度</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_pred</span>(<span class="params">dv_set, model, device, lim=<span class="number">35.</span>, preds=<span class="literal">None</span>, targets=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">''' Plot prediction of your DNN '''</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> preds <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> targets <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># test</span></span><br><span class="line">        model.<span class="built_in">eval</span>()</span><br><span class="line">        preds, targets = [], []</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> dv_set:</span><br><span class="line">            x, y = x.to(device), y.to(device)</span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                pred = model(x)</span><br><span class="line">                preds.append(pred.detach().cpu())</span><br><span class="line">                targets.append(y.detach().cpu())</span><br><span class="line">        preds = torch.cat(preds, dim=<span class="number">0</span>).numpy()</span><br><span class="line">        targets = torch.cat(targets, dim=<span class="number">0</span>).numpy()</span><br><span class="line"></span><br><span class="line">    figure(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">    plt.scatter(targets, preds, c=<span class="string">'r'</span>, alpha=<span class="number">0.5</span>)<span class="comment"># 绘制点图</span></span><br><span class="line">    plt.plot([-<span class="number">0.2</span>, lim], [-<span class="number">0.2</span>, lim], c=<span class="string">'b'</span>)</span><br><span class="line">    plt.xlim(-<span class="number">0.2</span>, lim)</span><br><span class="line">    plt.ylim(-<span class="number">0.2</span>, lim)</span><br><span class="line">    plt.xlabel(<span class="string">'ground truth value'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'predicted value'</span>)</span><br><span class="line">    plt.title(<span class="string">'Ground Truth v.s. Prediction'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202209070950422.png" alt="image-20220907095057378"></p>
<p>绘制点以及曲线</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">colors = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y:</span><br><span class="line">    t = i.item(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> t &gt; <span class="number">0</span>:</span><br><span class="line">        colors.append(<span class="string">'red'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        colors.append(<span class="string">'blue'</span>)</span><br><span class="line">plt.scatter(x,y,c=colors)</span><br><span class="line">x_range = np.linspace(<span class="number">0</span>,<span class="number">80</span>)</span><br><span class="line">plt.ylim(-<span class="number">5.</span>,<span class="number">3.0</span>)</span><br><span class="line">plt.plot(x_range,(w*x_range+b).T.squeeze())  </span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202210080022223.png" alt="image-20221008002201147"></p>
<p>子图绘制</p>
<p>方式1</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ax1.hist(np.random.randn(<span class="number">100</span>), bins=<span class="number">20</span>, color=<span class="string">'k'</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">ax2.scatter(np.arange(<span class="number">30</span>), np.arange(<span class="number">30</span>) + <span class="number">3</span> * np.random.randn(<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">x = np.linspace(-<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,dtype=<span class="built_in">float</span>)</span><br><span class="line">ax3.plot(x,np.sin(x))</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202209141319761.png" alt="image-20220914131952692" style="zoom: 50%;"></p>
<p>方式2</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up a subplot grid that has height 2 and width 1,</span></span><br><span class="line"><span class="comment"># and set the first such subplot as active.</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make the first plot</span></span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.title(<span class="string">'Sine'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the second subplot as active, and make the second plot.</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.title(<span class="string">'Cosine'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the figure.</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202209141401528.png" alt="image-20220914140156474"></p>
<p><code>%matplotlib inline</code>是IPython的魔法命令之一，用于在IPython notebook或Jupyter notebook中显示图形输出。具体而言，它会将matplotlib生成的图形嵌入到notebook中，并且不需要在单独的窗口中打开它们。</p>
<p>当在notebook中执行matplotlib绘图代码时，如果没有使用<code>%matplotlib inline</code>命令，则matplotlib默认情况下会创建一个新的窗口来显示图形。而使用<code>%matplotlib inline</code>命令后，所有的图形输出将直接显示在notebook中，便于查看和分析。</p>
<p>需要注意的是，<code>%matplotlib inline</code>命令必须在导入matplotlib库之前执行，才能确保所有的图形都能被正确地显示在notebook中。</p>
<p>利用matplotlib进行动态绘制（连续图像绘制）</p>
<p>因为python可视化库matplotlib的显示模式默认为阻塞（block）模式（即：在<code>plt.show()</code>之后，程序会暂停到那儿，并不会继续执行下去）。如何展示动态图或多个窗口 呢？使用<code>plt.ion()</code>这个函数，使matplotlib的显示模式转换为交互（interactive）模式。即使在脚本中遇到<code>plt.show( )</code>，代码还是会继续执行。在plt.show()之前一定不要忘了加plt.ioff()，如果不加，界面会一闪而过，并不会停留。</p>
<p>在阻塞模式下：</p>
<p><strong>1、打开一个窗口以后必须关掉才能打开下一个新的窗口。这种情况下，默认是不能像Matlab一样同时开很多窗口进行对比的。</strong></p>
<p><strong>2、plt.plot(x)或plt.imshow(x)是直接出图像，需要plt.show()后才能显示图像。</strong></p>
<p>在交互模式下：</p>
<p><strong>1、plt.plot(x)或plt.imshow(x)是直接出图像，不需要plt.show()。</strong></p>
<p><strong>2、如果在脚本中使用ion()命令开启了交互模式，没有使用ioff()关闭的话，则图像会一闪而过，并不会常留。要想防止这种情况，需要在plt.show()之前加上ioff()命令。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    plt.ion()  <span class="comment"># 打开交互模式</span></span><br><span class="line">    <span class="comment"># 同时打开两个窗口显示图片</span></span><br><span class="line">    x = np.linspace(-<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line">    y = np.sin(x)</span><br><span class="line">    plt.plot(x,y)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'sca'</span> <span class="keyword">in</span> <span class="built_in">globals</span>(): sca.remove()</span><br><span class="line">        sca = plt.scatter([i,i+<span class="number">1</span>], [<span class="number">0.5</span>,<span class="number">0.5</span>], s=<span class="number">200</span>, lw=<span class="number">0</span>, c=<span class="string">'red'</span>, alpha=<span class="number">0.5</span>);</span><br><span class="line">        plt.pause(<span class="number">0.05</span>)</span><br><span class="line">    plt.ioff()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p><code>plt.Rectangle</code></p>
<p><code>plt.Rectangle</code>是Matplotlib库中的一个类，用于在绘图中创建矩形对象。它可以用于绘制矩形形状、矩形边界框等。</p>
<p>下面是使用<code>plt.Rectangle</code>的一些基本用法示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个矩形对象</span></span><br><span class="line">rectangle = plt.Rectangle((<span class="number">0.2</span>, <span class="number">0.2</span>), <span class="number">0.4</span>, <span class="number">0.6</span>, color=<span class="string">'r'</span>,fill=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个图形对象</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将矩形对象添加到图形对象中</span></span><br><span class="line">ax.add_patch(rectangle)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴范围</span></span><br><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">ax.set_ylim(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们首先创建了一个<code>plt.Rectangle</code>对象，通过指定左下角的坐标 <code>(0.2, 0.2)</code>、宽度和高度来定义矩形的位置和大小。我们还指定了矩形的颜色为红色(<code>color='r'</code>)。</p>
<p>然后，我们创建了一个图形对象 <code>fig</code> 和一个坐标轴对象 <code>ax</code>。我们将矩形对象添加到坐标轴对象中，使用 <code>ax.add_patch(rectangle)</code> 方法。</p>
<p>最后，我们通过设置坐标轴的范围 <code>ax.set_xlim(0, 1)</code> 和 <code>ax.set_ylim(0, 1)</code>，确保矩形在指定的范围内可见。最后调用 <code>plt.show()</code> 来显示图形。</p>
<p>通过调整矩形的参数，例如位置、大小、颜色等，你可以根据需要自定义和绘制不同的矩形形状</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202305160919624.png" alt="image-20230516091901545"></p>
<h2 id="Seaborn"><a href="#Seaborn" class="headerlink" title="Seaborn"></a>Seaborn</h2><embed id="pdfPlayer" src="D:\data\jianyue\pdf\十分钟掌握 Seaborn，进阶 Python 数据可视化分析.pdf" width="100%" height="600">

<h2 id="tensorflow"><a href="#tensorflow" class="headerlink" title="tensorflow"></a>tensorflow</h2><h3 id="tensor创建"><a href="#tensor创建" class="headerlink" title="tensor创建"></a>tensor创建</h3><p><code>tf.zeros(维度)</code></p>
<p>创建全为0的tensor</p>
<p><code>tf.ones(维度)</code></p>
<p>创建全为1的tensor</p>
<p><code>tf.fill(维度，指定值)</code></p>
<p>创建指定值的tensor</p>
<p><code>tf.random.normal(维度，mean=均值，stddev=标准差)</code></p>
<p>生成正态分布的随机数，默认均值为0，标准差为1</p>
<p><code>tf.random.truncated_normal(维度，mean=均值，stddev=标准差)</code></p>
<p>保证生成的随机数在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.489ex;" xmlns="http://www.w3.org/2000/svg" width="1.364ex" height="1.489ex" role="img" focusable="false" viewBox="0 -442 603 658"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D707" d="M58 -216Q44 -216 34 -208T23 -186Q23 -176 96 116T173 414Q186 442 219 442Q231 441 239 435T249 423T251 413Q251 401 220 279T187 142Q185 131 185 107V99Q185 26 252 26Q261 26 270 27T287 31T302 38T315 45T327 55T338 65T348 77T356 88T365 100L372 110L408 253Q444 395 448 404Q461 431 491 431Q504 431 512 424T523 412T525 402L449 84Q448 79 448 68Q448 43 455 35T476 26Q485 27 496 35Q517 55 537 131Q543 151 547 152Q549 153 557 153H561Q580 153 580 144Q580 138 575 117T555 63T523 13Q510 0 491 -8Q483 -10 467 -10Q446 -10 429 -4T402 11T385 29T376 44T374 51L368 45Q362 39 350 30T324 12T288 -4T246 -11Q199 -11 153 12L129 -85Q108 -167 104 -180T92 -202Q76 -216 58 -216Z"></path></g></g></g></svg></mjx-container>+/-<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.423ex" height="1.532ex" role="img" focusable="false" viewBox="0 -666 1071 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g></g></g></svg></mjx-container>之内,数据更加向均值集中</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072015871.png" alt="image-20230107201508711"></p>
<p><code>tf.random.uniform(维度，minval=最小值，maxval=最大值)</code></p>
<p>生成均匀分布随机数[minval,maxval)</p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p><code>tf.cast(张量名,dtype=数据类型)</code></p>
<p>强制tensor转换为该数据类型</p>
<p><code>tf.reduce_min(张量名)</code></p>
<p>计算张量维度上元素最小值</p>
<p><code>tf.reduce_max(张量名)</code></p>
<p>计算张量维度上的最大值</p>
<p><code>tf.reduce_mean(张量名,axis=)</code></p>
<p>计算张量沿着指定维度的平均值</p>
<p><code>tf.reduce_sum(张量名,axis=)</code></p>
<p>计算张量沿着指定维度的和</p>
<p><code>tf.Variable()</code></p>
<p>将变量标记为可训练的</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072126182.png" alt="image-20230107212622090"></p>
<p>tf中常用的数学运算</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072131637.png" alt="image-20230107213130561"></p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072152130.png" alt="image-20230107215214038"></p>
<p><code>tf.data.Dataset.from_tensor_slices</code></p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072203685.png" alt="image-20230107220356609"></p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072204665.png" alt="image-20230107220413566"></p>
<p><code>tf.GradientTape</code></p>
<p>with结构中记录计算过程，gradient求出张量的梯度</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072206399.png" alt="image-20230107220637294"></p>
<p><code>enumerate</code></p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072207445.png" alt="image-20230107220743356"></p>
<p><code>tf.one_hot</code></p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072210190.png" alt="image-20230107221011113"></p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072211381.png" alt="image-20230107221105289"></p>
<p><code>tf.nn.softmax</code></p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072213870.png" alt="image-20230107221313729"></p>
<p><code>assign_sub</code></p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072214197.png" alt="image-20230107221452097"></p>
<p><code>tf.argmax</code></p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072215454.png" alt="image-20230107221553307"></p>
<p><code>tf.where</code></p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202301072323772.png" alt="image-20230107232314655"></p>
<p><code>tf.distributions.Normal(self.mu, self.sigma)</code></p>
<p>根据Mu和sigma求出一个正太分布，这个是随机的正态分布</p>
<p><code>tf.clip_by_value</code></p>
<p>tf.clip_by_value(A, min, max)：输入一个张量A，把A中的每一个元素的值都压缩在min和max之间。小于min的让它等于min，大于max的元素的值等于max。</p>
<h3 id="tensorflow-probability"><a href="#tensorflow-probability" class="headerlink" title="tensorflow_probability"></a>tensorflow_probability</h3><p><code>tensorflow_probability</code> 是基于 TensorFlow 的一个概率编程库，它提供了许多用于概率建模和推断的工具和算法，可以用于深度学习、统计学习、贝叶斯推断、概率编程等领域。它是 TensorFlow 生态系统中的一个子项目，由 TensorFlow 官方支持和维护。</p>
<p><code>tensorflow_probability</code> 包含了很多常用的概率分布类，例如正态分布、多项式分布、贝塔分布等，还包括许多概率模型，例如高斯混合模型、马尔可夫链蒙特卡罗（MCMC）模型等。此外，它还提供了许多常用的推断算法，例如变分推断、哈密顿蒙特卡罗（HMC）算法等，可以用于学习和推断概率模型。</p>
<p><code>tensorflow_probability</code> 的设计理念是利用 TensorFlow 的计算图和自动微分机制，为概率编程提供高效、可扩展和易用的工具。因此，它与 TensorFlow 紧密集成，可以直接利用 TensorFlow 的张量操作和优化器等功能，实现高效的概率编程。</p>
<p><strong>tfp.distributions.MultivariateNormalFullCovariance</strong></p>
<p><code>MultivariateNormalFullCovariance</code> 是 TensorFlow 中的一个概率分布类，表示一个具有多元正态分布的随机变量。它接受两个参数：均值向量和协方差矩阵，可以使用它来构建一个多元正态分布的概率模型。</p>
<p>下面是一个示例代码，展示了如何使用 <code>MultivariateNormalFullCovariance</code> 类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow_probability <span class="keyword">as</span> tfp</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义均值向量和协方差矩阵</span></span><br><span class="line">mu = [<span class="number">0.</span>, <span class="number">1.</span>]</span><br><span class="line">cov = [[<span class="number">1.</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">2.</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个多元正态分布模型</span></span><br><span class="line">mvn = tfp.distributions.MultivariateNormalFullCovariance(loc=mu, covariance_matrix=cov)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一些样本</span></span><br><span class="line">samples = mvn.sample(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算概率密度函数</span></span><br><span class="line">pdf = mvn.prob(samples)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"samples: \n"</span>, samples)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"pdf: \n"</span>, pdf)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">samples: </span></span><br><span class="line"><span class="string"> tf.Tensor(</span></span><br><span class="line"><span class="string">[[-0.76739496  2.204533  ]</span></span><br><span class="line"><span class="string"> [-0.5291017  -1.2480607 ]</span></span><br><span class="line"><span class="string"> [ 0.2066121  -0.3552009 ]</span></span><br><span class="line"><span class="string"> [-0.3798596   2.0005732 ]</span></span><br><span class="line"><span class="string"> [-0.3424486   1.2140272 ]</span></span><br><span class="line"><span class="string"> [-0.9631925   1.9374372 ]</span></span><br><span class="line"><span class="string"> [-0.343555    1.0946357 ]</span></span><br><span class="line"><span class="string"> [ 0.83072865 -0.9090407 ]</span></span><br><span class="line"><span class="string"> [ 0.22511458 -0.35162723]</span></span><br><span class="line"><span class="string"> [-1.363401    1.9629669 ]], shape=(10, 2), dtype=float32)</span></span><br><span class="line"><span class="string">pdf: </span></span><br><span class="line"><span class="string"> tf.Tensor(</span></span><br><span class="line"><span class="string">[0.04359382 0.03398798 0.06413195 0.07466278 0.1087476  0.04255811</span></span><br><span class="line"><span class="string"> 0.11113843 0.01819854 0.06357419 0.02192882], shape=(10,), dtype=float32)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们首先定义了均值向量 <code>mu</code> 和协方差矩阵 <code>cov</code>。然后，我们使用这些参数创建了一个 <code>MultivariateNormalFullCovariance</code> 对象 <code>mvn</code>，它表示一个多元正态分布。接着，我们使用 <code>mvn.sample(10)</code> 生成了 10 个样本，并计算了这些样本的概率密度函数。</p>
<p>你可以根据自己的需求来修改均值向量和协方差矩阵，从而创建不同的多元正态分布模型。另外，<code>MultivariateNormalFullCovariance</code> 类还提供了其他一些方法，例如 <code>log_prob()</code>、<code>entropy()</code> 等，可以用于计算概率密度函数的对数、熵等。</p>
<p>在上面的例子中，<code>prob</code> 函数是 <code>tensorflow_probability</code> 中 <code>MultivariateNormalFullCovariance</code> 类的一个方法，它的作用是计算给定样本的概率密度函数值。</p>
<p>具体来说，<code>prob</code> 方法接受一个张量作为输入，这个张量的每一行代表一个样本，每一列代表一个特征。它返回一个形状与输入张量相同的张量，每个元素代表相应样本的概率密度函数值。</p>
<p>在本例中，我们首先通过 <code>mvn.sample(10)</code> 生成了 10 个样本，然后通过 <code>mvn.prob(samples)</code> 计算了这些样本的概率密度函数值。这个结果告诉我们这些样本在多元正态分布模型下的概率密度大小，可以用于评估样本的合理性、寻找异常值等任务。</p>
<p>需要注意的是，<code>prob</code> 方法仅适用于概率密度函数已知的分布，对于一些无法计算概率密度函数的分布，例如混合分布，需要使用其他方法来评估样本的合理性，例如计算似然函数、负对数似然函数等。</p>
<p>需要注意的是，<code>prob</code> 方法返回的值并不是概率，而是概率密度函数的值。</p>
<p>在概率论中，概率密度函数（Probability Density Function，简称 PDF）是指某个随机变量落在某个区间内的概率在该区间长度趋于零时的极限，即密度函数在该点处的函数值。因此，概率密度函数的值并不代表概率，而是代表了某个区间内的概率密度大小。</p>
<p>对于连续型随机变量，我们无法像离散型随机变量那样直接计算概率，而是需要通过概率密度函数进行计算。具体来说，某个区间内的概率可以通过该区间内概率密度函数的积分来计算。</p>
<p>在本例中，<code>mvn.prob(samples)</code> 返回的是样本在多元正态分布模型下的概率密度函数值，它的大小反映了该样本在该分布下的密度大小，而不是该样本出现的概率。因此，在实际使用中需要注意区分概率和概率密度函数的概念。</p>
<h2 id="sklearn"><a href="#sklearn" class="headerlink" title="sklearn"></a>sklearn</h2><h3 id="sklearn流水线（Pipeline）"><a href="#sklearn流水线（Pipeline）" class="headerlink" title="sklearn流水线（Pipeline）"></a><strong>sklearn流水线（Pipeline）</strong></h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/536194668">参考</a></p>
<p>在机器学习或数据科学的实践中，经常需要对原始数据进行一系列的变换，或依次使用若干算法，从而构成一个算法链（algorithm chains）。比如，先对原始数据进行标准化（standardization）的预处理，然后再估计支持向量机的模型。为此，Sci-Kit Learn模块提供了方便的流水线类（Pipeline class），使得创建“算法链”的过程更简单。而且，Pipeline类可与GridSearchCV类相结合，针对整个算法进行超参数的网格搜索。</p>
<p>流水线流程</p>
<p>简易流水线流程</p>
<p>Pipeline()的参数为一个有“步骤”（steps）组称的列表。每个步骤（step）则为一个元组，包括该步骤的名称（可自行命名），比如“’scaler’”或“’svm’”，以及此步骤所有估计量的实例（an instance of an estimator），比如“StandardScaler()”或“SVC()”。此命令生成Pipeline类的一个实例pipe。使用type()函数查看此对象类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个流水线实例，暂时不进行交叉验证</span></span><br><span class="line">pipe = Pipeline([(<span class="string">'scaler'</span>, StandardScaler()), (<span class="string">'svm'</span>, SVC())])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看类型</span></span><br><span class="line"><span class="built_in">type</span>(pipe)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用实例pipe的fit()方法进行估计</span></span><br><span class="line">pipe.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测测试集</span></span><br><span class="line">pipe.score(X_test, y_test)</span><br></pre></td></tr></table></figure>
<p>常规的流水线流程</p>
<p>使用交叉验证法进行参数网格搜索。由于这些超参数可能出现于管线的不同步骤，故须以“双下划线”的格式指定超参数所在的步骤</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">param_grid = {<span class="string">'svm__C'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>],   <span class="comment"># "svm_C"表示步骤"svm"的参数"C",中间以双下划线连接</span></span><br><span class="line">             <span class="string">'svm__gamma'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]}</span><br><span class="line"></span><br><span class="line">model = GridSearchCV(pipe, param_grid=param_grid, cv=kfold)</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"流水线预测准确度："</span>, model.score(X_test, y_test))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"流水线最佳参数："</span>, model.best_params_)</span><br></pre></td></tr></table></figure>
<p>对于管线中的每个步骤，均可使用named<em>steps()方法，考察其相应的属性。比如考察“svm”步骤共有多少个支持向量，可使用SVC类的n_surpport</em>属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看支持向量的个数</span></span><br><span class="line">pipe.named_steps[<span class="string">'svm'</span>].n_support_</span><br><span class="line"><span class="comment"># 展示支持向量的观测值的索引</span></span><br><span class="line">pipe.named_steps[<span class="string">'svm'</span>].support_</span><br><span class="line"><span class="comment"># 展示支持向量</span></span><br><span class="line">pipe.named_steps[<span class="string">'svm'</span>].support_vectors_</span><br></pre></td></tr></table></figure>
<p>使用Pipeline()建立Pipeline类的一个实例，需指定每个步骤的名称。若不想指定管线中的每个步骤的名称，也可使用更为简便的make_pipeline()函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pipe_long = Pipeline([(<span class="string">'scaler'</span>, StandardScaler()), (<span class="string">'svm'</span>, SVC())])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">pipe_short = make_pipeline(StandardScaler(), SVC())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用管线的steps属性，考察管线pipelong的步骤细节</span></span><br><span class="line">pipe_long.steps</span><br><span class="line">pipe_short.steps</span><br></pre></td></tr></table></figure>
<h3 id="sklearn中RBFSampler的用法"><a href="#sklearn中RBFSampler的用法" class="headerlink" title="sklearn中RBFSampler的用法"></a><strong>sklearn中RBFSampler的用法</strong></h3><p><code>RBFSampler</code> 是 <code>sklearn</code> 中的一个随机特征映射器，可以将原始特征空间映射到高维空间中。其主要用途是通过随机投影将非线性分类问题转换为线性分类问题，从而提高模型的效率和精度。</p>
<p><code>RBFSampler</code> 的主要参数如下：</p>
<ul>
<li><code>gamma</code>：RBF核的带宽参数。默认为 1.0。</li>
<li><code>n_components</code>：随机映射后的特征空间的维度。默认为 100。</li>
<li><code>random_state</code>：随机数种子。默认为 None。</li>
</ul>
<p>下面是一个简单的示例，展示如何使用 <code>RBFSampler</code> 进行特征映射：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.kernel_approximation <span class="keyword">import</span> RBFSampler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个二分类问题的样本数据</span></span><br><span class="line">X, y = make_classification(n_features=<span class="number">20</span>, n_samples=<span class="number">10000</span>, n_informative=<span class="number">10</span>, n_redundant=<span class="number">0</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义随机特征映射器，将原始特征空间映射到高维空间中</span></span><br><span class="line">rbf_feature = RBFSampler(gamma=<span class="number">1</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义分类器，并将特征映射器和标准化器组成流水线</span></span><br><span class="line">clf = make_pipeline(StandardScaler(), rbf_feature, SGDClassifier())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练分类器</span></span><br><span class="line">clf.fit(X, y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们首先生成了一个二分类问题的样本数据。然后，我们定义了一个 <code>RBFSampler</code> 对象，将原始特征空间映射到高维空间中。接着，我们将 <code>RBFSampler</code> 对象、标准化器和线性分类器组成了一个流水线，并使用训练数据对其进行训练。</p>
<h3 id="model-selection"><a href="#model-selection" class="headerlink" title="model_selection"></a>model_selection</h3><p>在 sklearn 中，<code>model_selection</code> 模块包含了一些用于模型选择和性能评估的工具。其中包括以下功能：</p>
<ul>
<li><code>train_test_split</code>：将数据集划分为训练集和测试集；</li>
<li><code>KFold</code>：K 折交叉验证；</li>
<li><code>GridSearchCV</code>：基于网格搜索的参数调优方法；</li>
<li><code>RandomizedSearchCV</code>：基于随机搜索的参数调优方法；</li>
<li><code>cross_val_score</code>：基于交叉验证的模型评估方法。</li>
</ul>
<p>下面简要介绍一下这些功能：</p>
<ul>
<li><code>train_test_split</code>：将数据集划分为训练集和测试集，用于模型训练和性能评估；</li>
<li><code>KFold</code>：K 折交叉验证，将数据集划分为 K 份，每次使用其中一份作为验证集，剩下的 K-1 份作为训练集，重复 K 次，最终将每次的评估结果进行平均；</li>
<li><code>GridSearchCV</code>：基于网格搜索的参数调优方法，可以指定需要调优的参数以及其可能的取值范围，使用交叉验证来评估模型的性能，并选择最佳参数组合；</li>
<li><code>RandomizedSearchCV</code>：基于随机搜索的参数调优方法，与 <code>GridSearchCV</code> 相似，但不需要指定所有可能的参数组合，而是随机从可能的取值范围中抽样，来寻找最佳参数组合；</li>
<li><code>cross_val_score</code>：基于交叉验证的模型评估方法，使用交叉验证来评估模型的性能，可以计算模型的平均精度、准确率、召回率等指标。</li>
</ul>
<p>这些功能提供了一些便利的工具，可以帮助你更好地选择和评估机器学习模型。在使用这些功能时，你需要了解它们的参数和使用方法。建议参考官方文档和相关的教程学习更多细节。</p>
<h4 id="train-test-split"><a href="#train-test-split" class="headerlink" title="train_test_split"></a><code>train_test_split</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 DataFrame</span></span><br><span class="line">df = pd.DataFrame({<span class="string">'A'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="string">'B'</span>: [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>], <span class="string">'C'</span>: [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]})</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 将 DataFrame 随机分成训练集和测试集</span></span><br><span class="line">train_df, test_df = train_test_split(df, test_size=<span class="number">0.5</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印训练集和测试集</span></span><br><span class="line"><span class="built_in">print</span>(train_df)</span><br><span class="line"><span class="built_in">print</span>(test_df)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  A   B   C</span></span><br><span class="line"><span class="string">0  1   6  11</span></span><br><span class="line"><span class="string">1  2   7  12</span></span><br><span class="line"><span class="string">2  3   8  13</span></span><br><span class="line"><span class="string">3  4   9  14</span></span><br><span class="line"><span class="string">4  5  10  15</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   A  B   C</span></span><br><span class="line"><span class="string">0  1  6  11</span></span><br><span class="line"><span class="string">3  4  9  14</span></span><br><span class="line"><span class="string">   A   B   C</span></span><br><span class="line"><span class="string">1  2   7  12</span></span><br><span class="line"><span class="string">4  5  10  15</span></span><br><span class="line"><span class="string">2  3   8  13</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h2 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a>pytorch</h2><p>   pytorch中，一般来说如果对tensor的一个函数后加上了下划线，则表明这是一个in-place类型。in-place类型是指，当在一个tensor上操作了之后，是直接修改了这个tensor，而不是返回一个新的tensor并不修改旧的tensor。</p>
<p><code>numel</code></p>
<p>numel就是”number of elements”的简写。numel()可以直接返回int类型的元素个数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line">a = torch.randn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">b = a.numel()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b)) <span class="comment"># int</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># 24</span></span><br></pre></td></tr></table></figure>
<p><code>normal</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">normal(mean, std, *, generator=<span class="literal">None</span>, out=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>该函数返回从单独的正态分布中提取的随机数的张量，该正态分布的均值是mean，标准差是std。<br>用法如下：我们从一个标准正态分布N～(0,1)，提取一个2x2的矩阵</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.normal(mean=<span class="number">0.</span>,std=<span class="number">1.</span>,size=(<span class="number">2</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202302142132820.png" alt="image-20230214213222756"></p>
<p>我们也可以让每一个值服从不同的正态分布，我们还是生成2x2的矩阵：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.normal(mean=torch.arange(<span class="number">4.</span>),std=torch.arange(<span class="number">1.</span>,<span class="number">0.6</span>,-<span class="number">0.1</span>)).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202302142133772.png" alt="image-20230214213300709"></p>
<p><code>max</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pred = torch.tensor([[<span class="number">0.7</span>,<span class="number">0</span>,<span class="number">0.2</span>,<span class="number">0.1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0.2</span>,<span class="number">0.4</span>,<span class="number">0.3</span>,<span class="number">0.1</span>]])</span><br><span class="line">a = pred.<span class="built_in">max</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">torch.return_types.max(</span></span><br><span class="line"><span class="string">values=tensor([[0.7000],</span></span><br><span class="line"><span class="string">        [0.4000]]),</span></span><br><span class="line"><span class="string">indices=tensor([[0],</span></span><br><span class="line"><span class="string">        [2]]))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">tensor([[0],</span></span><br><span class="line"><span class="string">        [2]])</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p><code>sum</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pred = torch.tensor([[<span class="number">0.7</span>,<span class="number">0</span>,<span class="number">0.2</span>,<span class="number">0.1</span>,<span class="number">0</span>],									 [<span class="number">0</span>,<span class="number">0.2</span>,<span class="number">0.4</span>,<span class="number">0.3</span>,<span class="number">0.1</span>]])</span><br><span class="line">a = pred.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># tensor([1., 1.]),自动降维</span></span><br><span class="line">a = pred.<span class="built_in">sum</span>(axis=<span class="number">1</span>,keepdim=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[1.],</span></span><br><span class="line"><span class="string">        [1.]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>detach()</code></p>
<p>detach() &amp; data()</p>
<p>detach()返回一个新的tensor，是从当前计算图中分离下来的，但是仍指向原变量的存放位置，其grad_fn=None且requires_grad=False，得到的这个tensor永远不需要计算其梯度，不具有梯度grad，即使之后重新将它的requires_grad置为true,它也不会具有梯度grad。</p>
<p><code>clamp()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.clamp(<span class="built_in">input</span>, <span class="built_in">min</span>, <span class="built_in">max</span>, out=<span class="literal">None</span>) → Tensor</span><br></pre></td></tr></table></figure>
<p>将输入<code>input</code>张量每个元素的夹紧到区间 [min ,max]，，并返回结果到一个新张量。</p>
<p>操作定义如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      | min, if x_i &lt; min</span><br><span class="line">y_i = | x_i, if min &lt;= x_i &lt;= max</span><br><span class="line">      | max, if x_i &gt; max</span><br></pre></td></tr></table></figure>
<p>如果输入是FloatTensor or DoubleTensor类型，则参数<code>min</code> <code>max</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>min</code>， <code>max</code>取整数、实数皆可。】</p>
<p>参数：</p>
<ul>
<li>input (Tensor) – 输入张量</li>
<li>min (Number) – 限制范围下限</li>
<li>max (Number) – 限制范围上限</li>
<li>out (Tensor, optional) – 输出张量</li>
</ul>
<p>代码示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">a=torch.randint(low=<span class="number">0</span>,high=<span class="number">10</span>,size=(<span class="number">10</span>,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a=torch.clamp(a,<span class="number">3</span>,<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">tensor([[9.],</span></span><br><span class="line"><span class="string">        [3.],</span></span><br><span class="line"><span class="string">        [0.],</span></span><br><span class="line"><span class="string">        [4.],</span></span><br><span class="line"><span class="string">        [4.],</span></span><br><span class="line"><span class="string">        [2.],</span></span><br><span class="line"><span class="string">        [4.],</span></span><br><span class="line"><span class="string">        [1.],</span></span><br><span class="line"><span class="string">        [2.],</span></span><br><span class="line"><span class="string">        [9.]])</span></span><br><span class="line"><span class="string">tensor([[9.],</span></span><br><span class="line"><span class="string">        [3.],</span></span><br><span class="line"><span class="string">        [3.],</span></span><br><span class="line"><span class="string">        [4.],</span></span><br><span class="line"><span class="string">        [4.],</span></span><br><span class="line"><span class="string">        [3.],</span></span><br><span class="line"><span class="string">        [4.],</span></span><br><span class="line"><span class="string">        [3.],</span></span><br><span class="line"><span class="string">        [3.],</span></span><br><span class="line"><span class="string">        [9.]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p><strong>torch.distributions.Categorical</strong></p>
<p><code>torch.distributions.Categorical</code> 是 PyTorch 中的一个分布类，它表示具有固定类别概率的离散分布。使用 <code>Categorical</code> 类，您可以创建一个离散分布对象，其中每个类别的概率由输入的概率张量确定。</p>
<p>以下是一个使用 <code>Categorical</code> 类的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.distributions <span class="keyword">import</span> Categorical</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个概率张量，表示三个类别的概率分别为 0.3、0.5 和 0.2</span></span><br><span class="line">probs = torch.tensor([<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Categorical 分布对象</span></span><br><span class="line">dist = Categorical(probs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从分布中抽样</span></span><br><span class="line">sample = dist.sample()</span><br><span class="line"><span class="built_in">print</span>(sample)  <span class="comment"># 输出抽样结果，可能为 0、1 或 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 log 概率密度函数</span></span><br><span class="line">log_prob = dist.log_prob(sample)</span><br><span class="line"><span class="built_in">print</span>(log_prob)  <span class="comment"># 输出 log 概率密度函数的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里，我们首先定义了一个概率张量，其中三个类别的概率分别为 0.3、0.5 和 0.2。然后，我们使用 <code>Categorical</code> 类创建了一个分布对象 <code>dist</code>，其中每个类别的概率由概率张量 <code>probs</code> 确定。接着，我们使用 <code>sample()</code> 方法从分布中抽样，返回一个表示抽样结果的张量。最后，我们使用 <code>log_prob()</code> 方法计算抽样结果的对数概率密度函数的值。</p>
<p>需要注意的是，<code>Categorical</code> 类的概率张量必须是非负的，并且总和必须为 1。如果概率张量不满足这些条件，<code>Categorical</code> 类将引发异常。如果您的概率张量不满足这些条件，您可以使用 <code>torch.softmax()</code> 函数将其转换为满足条件的概率张量。</p>
<p><strong>torch.stack</strong></p>
<p>在<code>pytorch</code>中，常见的拼接函数主要是两个，分别是：</p>
<ol>
<li><code>stack()</code></li>
<li><code>cat()</code></li>
</ol>
<p>实际使用中，这两个函数互相辅助，使用场景不同：关于<code>cat()</code>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/xinjieyuan/article/details/105208352">torch.cat()</a>，但是本文主要说<code>stack()</code>。</p>
<p><strong>函数的意义</strong>：使用<code>stack</code>可以保留两个信息：[1. 序列] 和 [2. 张量矩阵] 信息，属于【<strong>扩张</strong>再拼接】的函数。</p>
<p>形象的理解：假如数据都是二维矩阵(平面)，它可以把这些一个个平面按第三维(例如：时间序列)压成一个三维的立方体，而立方体的长度就是时间序列长度。</p>
<p>该函数常出现在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=自然语言处理&amp;spm=1001.2101.3001.7020">自然语言处理</a>（<code>NLP</code>）和图像卷积<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=神经网络&amp;spm=1001.2101.3001.7020">神经网络</a>(<code>CV</code>)中。</p>
<p><code>stack()</code></p>
<p>官方解释：沿着一个新维度对输入张量序列进行连接。 序列中所有的张量都应该为相同形状。</p>
<p>浅显说法：把多个2维的张量凑成一个3维的张量；多个3维的凑成一个4维的张量…以此类推，也就是在<strong>增加新的维度进行堆叠</strong>。</p>
<p><code>outputs = torch.stack(inputs, dim=?) → Tensor</code></p>
<p><strong>参数</strong></p>
<ul>
<li>inputs : 待连接的张量序列。<br>注：<code>python</code>的序列数据只有<code>list</code>和<code>tuple</code>。</li>
<li>dim : 新的维度， 必须在<code>0</code>到<code>len(outputs)</code>之间。<br>注：<code>len(outputs)</code>是生成数据的维度大小，也就是<code>outputs</code>的维度值。</li>
</ul>
<ol>
<li><p>重点</p>
</li>
<li><p>函数中的输入<code>inputs</code>只允许是序列；且序列内部的张量元素，必须<code>shape</code>相等</p>
</li>
</ol>
<p>——举例：<code>[tensor_1, tensor_2,..]</code>或者<code>(tensor_1, tensor_2,..)</code>，且必须<code>tensor_1.shape == tensor_2.shape</code></p>
<ol>
<li><code>dim</code>是选择生成的维度，必须满足<code>0&lt;=dim&lt;len(outputs)</code>；<code>len(outputs)</code>是输出后的<code>tensor</code>的维度大小</li>
</ol>
<p>不懂的看例子，再回过头看就懂了。</p>
<ol>
<li>例子</li>
</ol>
<p>1.准备2个<code>tensor</code>数据，每个的<code>shape</code>都是<code>[3,3]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设是时间步T1的输出</span></span><br><span class="line">T1 = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        		[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">        		[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="comment"># 假设是时间步T2的输出</span></span><br><span class="line">T2 = torch.tensor([[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">        		[<span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>],</span><br><span class="line">        		[<span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]])</span><br></pre></td></tr></table></figure>
<p>2.测试stack函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(torch.stack((T1,T2),dim=<span class="number">0</span>).shape)</span><br><span class="line"><span class="built_in">print</span>(torch.stack((T1,T2),dim=<span class="number">1</span>).shape)</span><br><span class="line"><span class="built_in">print</span>(torch.stack((T1,T2),dim=<span class="number">2</span>).shape)</span><br><span class="line"><span class="built_in">print</span>(torch.stack((T1,T2),dim=<span class="number">3</span>).shape)</span><br><span class="line"><span class="comment"># outputs:</span></span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">torch.Size([<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">torch.Size([<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"><span class="string">'选择的dim&gt;len(outputs)，所以报错'</span></span><br><span class="line">IndexError: Dimension out of <span class="built_in">range</span> (expected to be <span class="keyword">in</span> <span class="built_in">range</span> of [-<span class="number">3</span>, <span class="number">2</span>], but got <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>可以复制代码运行试试：拼接后的<code>tensor</code>形状，会根据不同的<code>dim</code>发生变化。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>dim</th>
<th>shape</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>[2, 3, 3]</td>
</tr>
<tr>
<td>1</td>
<td>[3, 2, 3]</td>
</tr>
<tr>
<td>2</td>
<td>[3, 3, 2]</td>
</tr>
<tr>
<td>3</td>
<td><strong>溢出报错</strong></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>总结</p>
</li>
<li><p>函数作用：<br>函数<code>stack()</code>对<strong>序列数据</strong>内部的张量进行扩维拼接，指定维度由程序员选择、大小是生成后数据的维度区间。</p>
</li>
<li>存在意义：<br>在自然语言处理和卷及神经网络中， <strong>通常为了保留–[序列(先后)信息] 和 [张量的矩阵信息]</strong> 才会使用<code>stack</code>。</li>
</ol>
<p>函数存在意义？》》》</p>
<p>手写过RNN的同学，知道在循环神经网络中输出数据是：一个<code>list</code>，该列表插入了<code>seq_len</code>个形状是<code>[batch_size, output_size]</code>的<code>tensor</code>，不利于计算，需要使用<code>stack</code>进行拼接，保留–[1.seq_len这个时间步]和–[2.张量属性<code>[batch_size, output_size]</code>]。</p>
<p> PyTorch中惰性模块初始化</p>
<p>LazyLinear</p>
<p>LazyConv2d</p>
<h3 id="torch-utils"><a href="#torch-utils" class="headerlink" title="torch.utils"></a>torch.utils</h3><h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4><h5 id="TensorDataset"><a href="#TensorDataset" class="headerlink" title="TensorDataset"></a>TensorDataset</h5><p>构造dataset</p>
<p>在下面的代码中，我们使用 TensorDataset 类将 X 和 y 张量打包成一个元组，并将其传递给 dataset 变量。现在，您可以使用这个 dataset 对象作为 PyTorch 的数据集，以进行后续的操作，例如将其传递给 DataLoader 进行批量处理等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> TensorDataset</span><br><span class="line"></span><br><span class="line">X = torch.tensor([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">y = torch.tensor([<span class="number">0</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">dataset = TensorDataset(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_array</span>(<span class="params">data_arrays, batch_size, is_train=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="string">"""Construct a PyTorch data iterator.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Defined in :numref:`sec_linear_concise`"""</span></span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)</span><br><span class="line">    <span class="keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)</span><br><span class="line">train_iter = load_array((X, y),batch_size, is_train=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="torch-nn"><a href="#torch-nn" class="headerlink" title="torch.nn"></a>torch.nn</h3><h4 id="functional"><a href="#functional" class="headerlink" title="functional"></a>functional</h4><h5 id="one-hot"><a href="#one-hot" class="headerlink" title="one_hot"></a>one_hot</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">F.one_hot(torch.tensor([<span class="number">0</span>,<span class="number">3</span>]),num_classes=<span class="number">5</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[1, 0, 0, 0, 0],</span></span><br><span class="line"><span class="string">        [0, 0, 0, 1, 0]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="AdaptiveAvgPool2d"><a href="#AdaptiveAvgPool2d" class="headerlink" title="AdaptiveAvgPool2d"></a>AdaptiveAvgPool2d</h4><p><code>nn.AdaptiveAvgPool2d</code>是PyTorch中的一个自适应平均池化层。平均池化是一种常用的操作，用于对输入数据进行降采样和特征提取。</p>
<p>传统的平均池化操作需要指定池化窗口的大小，然后在输入数据上以固定的步长进行滑动，将每个窗口内的数值取平均作为输出。但是，这种方式需要手动指定池化窗口的大小，导致网络对输入数据的尺寸有严格的要求。</p>
<p><code>nn.AdaptiveAvgPool2d</code>的作用是允许网络自动适应输入的尺寸，并在每个维度上进行自适应的平均池化。它接受一个输出尺寸作为参数，而不是指定池化窗口的大小。具体而言，对于输入的特征图，<code>nn.AdaptiveAvgPool2d</code>将自动计算出需要的池化窗口大小，以使输出尺寸与指定的输出尺寸一致。</p>
<p>例如，如果输入特征图的大小为<code>(batch_size, channels, height, width)</code>，并且我们希望输出的特征图大小为<code>(batch_size, channels, output_height, output_width)</code>，则可以使用<code>nn.AdaptiveAvgPool2d((output_height, output_width))</code>来实现。这样，池化窗口的大小将根据输入特征图的尺寸和指定的输出尺寸进行自适应计算。</p>
<p>自适应平均池化层的主要优势在于可以处理不同尺寸的输入数据，从而增加了网络的灵活性，并且避免了手动设置池化窗口大小的麻烦。它常用于卷积神经网络中，在降低空间分辨率的同时提取特征。</p>
<p>比如：</p>
<p>当输入特征图的尺寸不确定时，<code>nn.AdaptiveAvgPool2d</code>可以自适应地调整池化窗口的大小以适应不同的输入尺寸。下面是一个使用<code>nn.AdaptiveAvgPool2d</code>的简单示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个输入特征图</span></span><br><span class="line">batch_size = <span class="number">1</span></span><br><span class="line">channels = <span class="number">3</span></span><br><span class="line">height = <span class="number">32</span></span><br><span class="line">width = <span class="number">32</span></span><br><span class="line">input_tensor = torch.randn(batch_size, channels, height, width)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义自适应平均池化层</span></span><br><span class="line">output_size = (<span class="number">16</span>, <span class="number">16</span>)  <span class="comment"># 输出尺寸为16x16</span></span><br><span class="line">adaptive_avg_pool = nn.AdaptiveAvgPool2d(output_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对输入特征图进行自适应平均池化</span></span><br><span class="line">output_tensor = adaptive_avg_pool(input_tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果的尺寸</span></span><br><span class="line"><span class="built_in">print</span>(output_tensor.size())  <span class="comment"># 输出: torch.Size([1, 3, 16, 16])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们首先创建了一个大小为1x3x32x32的输入特征图。然后，我们定义了一个自适应平均池化层，指定输出尺寸为16x16。最后，我们将输入特征图传递给自适应平均池化层进行处理，得到一个大小为1x3x16x16的输出特征图。</p>
<p>通过使用<code>nn.AdaptiveAvgPool2d</code>，我们不需要显式地指定池化窗口的大小，而是根据输出尺寸自动计算池化窗口的大小，以适应输入特征图的尺寸。这使得网络在处理不同尺寸的输入时更加灵活和通用。</p>
<h4 id="ConvTranspose2d"><a href="#ConvTranspose2d" class="headerlink" title="ConvTranspose2d"></a>ConvTranspose2d</h4><p><code>nn.ConvTranspose2d</code>是PyTorch中的转置卷积（反卷积）层。转置卷积层用于将输入特征图扩展为更大的尺寸，相当于对普通卷积进行反向操作。</p>
<p>转置卷积的工作原理是通过使用卷积核的转置来实现图像的上采样。它可以在输入特征图上进行空间扩展，同时可以改变通道数。</p>
<p>下面是<code>nn.ConvTranspose2d</code>的示例用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, output_padding=<span class="number">0</span>, groups=<span class="number">1</span>, bias=<span class="literal">True</span>, dilation=<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<ul>
<li><code>in_channels</code>：输入特征图的通道数。</li>
<li><code>out_channels</code>：输出特征图的通道数。</li>
<li><code>kernel_size</code>：卷积核的大小。</li>
<li><code>stride</code>：步长（每次卷积核滑动的距离）。</li>
<li><code>padding</code>：输入特征图边缘填充的大小。</li>
<li><code>output_padding</code>：输出特征图边缘填充的大小，用于控制输出尺寸。</li>
<li><code>groups</code>：分组卷积的组数。</li>
<li><code>bias</code>：是否使用偏置项。</li>
<li><code>dilation</code>：卷积核元素之间的间距。</li>
</ul>
<p>转置卷积层通常用于将编码器中的低维表示进行解码和重构，将其扩展为与原始输入相同的尺寸。转置卷积的输出尺寸取决于输入尺寸、卷积核大小、步长和填充。</p>
<p>在卷积自动编码器中，转置卷积层常用于解码器部分，用于将压缩后的表示进行解码和重构，将其逐渐恢复为原始图像的尺寸。</p>
<p>当使用转置卷积时，它可以将一个较小的特征图扩展为一个较大的特征图。这里我将给你一个简单的例子来说明转置卷积的工作原理。</p>
<p>假设我们有一个输入特征图 <code>input</code>，它的大小为 <code>(1, 3, 4, 4)</code>，表示一个通道数为 3、高度和宽度均为 4 的特征图。我们想要使用转置卷积来将其扩展为一个 <code>(1, 3, 8, 8)</code> 大小的特征图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">conv_transpose = nn.ConvTranspose2d(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">output = conv_transpose(<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Input shape:"</span>, <span class="built_in">input</span>.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output shape:"</span>, output.shape)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行上述代码，我们得到以下输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input shape: torch.Size([1, 3, 4, 4])</span><br><span class="line">Output shape: torch.Size([1, 3, 8, 8])</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用了 <code>nn.ConvTranspose2d</code> 创建了一个转置卷积层 <code>conv_transpose</code>。它接受一个输入特征图 <code>input</code>，并根据指定的参数进行转置卷积操作。</p>
<p>在转置卷积的过程中，输入特征图的每个元素都会乘以卷积核中对应位置的权重，并加到输出特征图的相应位置上。由于步长为 2，所以输出特征图的尺寸是输入的两倍。</p>
<p>需要注意的是，转置卷积层的参数设置非常重要。通过调整转置卷积的参数，例如步长、填充和卷积核大小，可以控制输出特征图的尺寸。</p>
<p>转置卷积在卷积自动编码器等任务中经常用于解码器部分，将压缩的表示逐渐恢复为与原始输入相同的尺寸，从而实现图像的重构。</p>
<h3 id="torchvision"><a href="#torchvision" class="headerlink" title="torchvision"></a>torchvision</h3><h4 id="models"><a href="#models" class="headerlink" title="models"></a>models</h4><p><code>torchvision</code> is a package in the PyTorch ecosystem that provides various tools and utilities for working with computer vision tasks. One of the key features of <code>torchvision</code> is its pre-trained models, which are neural networks trained on large datasets such as ImageNet.</p>
<p>Here are some of the pre-trained models available in <code>torchvision</code>:</p>
<ol>
<li>AlexNet: a deep convolutional neural network (CNN) introduced in 2012, which was one of the first models to achieve high accuracy on the ImageNet dataset.</li>
<li>VGG: a series of CNNs with varying depths, developed by the Visual Geometry Group at the University of Oxford.</li>
<li>ResNet: a family of CNNs introduced in 2015 that includes skip connections, allowing the model to learn residual functions.</li>
<li>Inception: a family of CNNs that use a combination of different convolutional filters at different scales.</li>
<li>DenseNet: a CNN architecture that connects each layer to every other layer in a feed-forward fashion.</li>
<li>MobileNet: a lightweight CNN designed for mobile and embedded applications.</li>
<li>EfficientNet: a family of CNNs that use a compound scaling method to improve both accuracy and efficiency.</li>
</ol>
<p>These models are often used as a starting point for transfer learning, where a pre-trained model is fine-tuned on a new dataset for a specific task. This can greatly reduce the amount of training data and time needed to achieve high performance on a new task.</p>
<p>torchvision models 中关于resnet34的具体使用方法</p>
<p><code>resnet34</code>是<code>torchvision</code>中的一个预训练模型，是ResNet系列中的一个相对较小的模型。以下是使用<code>resnet34</code>进行预测的一个简单示例：</p>
<ol>
<li><p>导入所需的库和模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化预训练模型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = models.resnet34(pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>加载并预处理要进行预测的图像。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">img_path = <span class="string">'path/to/image.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义图像转换</span></span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.Resize(<span class="number">256</span>),  <span class="comment"># 调整图像大小为256x256</span></span><br><span class="line">    transforms.CenterCrop(<span class="number">224</span>),  <span class="comment"># 中心裁剪为224x224</span></span><br><span class="line">    transforms.ToTensor(),  <span class="comment"># 将图像转换为张量</span></span><br><span class="line">    transforms.Normalize(</span><br><span class="line">        mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],  <span class="comment"># ImageNet数据集的均值</span></span><br><span class="line">        std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]  <span class="comment"># ImageNet数据集的标准差</span></span><br><span class="line">    )</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载图像并进行转换</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">img_tensor = transform(img)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>将输入数据传入模型进行推断。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将输入数据添加一个批次的维度</span></span><br><span class="line">img_tensor = img_tensor.unsqueeze(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将模型设置为评估模式</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过模型进行推断</span></span><br><span class="line">output = model(img_tensor)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>img_path</code>表示要进行预测的图像路径，<code>transform</code>表示对图像进行的预处理操作，例如调整大小、裁剪、归一化等。在传递给模型之前，需要将图像转换为张量并添加一个批次的维度。在推断之前，需要将模型设置为评估模式。推断之后，<code>output</code>表示模型的输出，是一个形状为<code>[1, 1000]</code>的张量，其中1000表示模型预测的类别数。可以使用<code>torch.argmax(output)</code>来获取预测结果的类别索引。</p>
</li>
</ol>
<p><code>torchvision</code>中的<code>resnet34</code>模型使用的默认输入通道为3（RGB彩色图像），输出通道为1000（对应ImageNet数据集中的1000个类别）。如果需要自己定义输入通道和输出通道，可以通过修改模型的构造函数实现。以下是一个简单的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResNet34</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes, input_channels=<span class="number">3</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(ResNet34, self).__init__()</span><br><span class="line">        self.num_classes = num_classes</span><br><span class="line">        self.input_channels = input_channels</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 加载预训练模型</span></span><br><span class="line">        self.model = models.resnet34(pretrained=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 替换第一层卷积层</span></span><br><span class="line">        self.model.conv1 = nn.Conv2d(</span><br><span class="line">            input_channels, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 替换最后一层全连接层</span></span><br><span class="line">        self.model.fc = nn.Linear(<span class="number">512</span>, num_classes)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们首先定义了一个新的<code>ResNet34</code>类，它继承自<code>nn.Module</code>。在构造函数中，我们使用<code>super()</code>函数调用父类的构造函数，同时定义了<code>num_classes</code>和<code>input_channels</code>两个参数。在构造函数中，我们首先加载了<code>resnet34</code>预训练模型，然后替换了其第一层卷积层和最后一层全连接层，以适应自定义的输入通道和输出通道。</p>
<p>具体地，我们通过<code>self.model.conv1</code>来替换模型的第一层卷积层，这里我们使用了<code>nn.Conv2d</code>来定义新的卷积层，将其输入通道数设为<code>input_channels</code>，输出通道数设为64。类似地，我们通过<code>self.model.fc</code>来替换模型的最后一层全连接层，将其输入通道数设为512（<code>resnet34</code>模型的最后一层卷积层的输出通道数），输出通道数设为<code>num_classes</code>。</p>
<p>最后，我们在<code>forward()</code>函数中调用<code>self.model()</code>来实现前向传播。可以使用该自定义模型来训练自己的数据集，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">model = ResNet34(num_classes=<span class="number">10</span>, input_channels=<span class="number">1</span>) <span class="comment"># 假设输入通道为灰度图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在训练之前对模型进行设备设置</span></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数和优化器</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        images = images.to(device)</span><br><span class="line">        labels = labels.to(device)</span><br><span class="line">        </span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs =</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="transforms-ToTensor"><a href="#transforms-ToTensor" class="headerlink" title="transforms.ToTensor()"></a>transforms.ToTensor()</h4><p>这个操作将图像数据转换为张量形式。它将 PIL 图像对象或 NumPy 数组转换为张量，并对像素值进行归一化到范围 [0, 1]。</p>
<p>在 PyTorch 中，<code>transforms.ToTensor()</code> 操作会将输入的 PIL 图像对象或 NumPy 数组转换为张量形式，但不会改变图像的像素值。</p>
<p>具体而言，<code>transforms.ToTensor()</code> 将图像的每个像素值从整数或浮点数类型转换为范围在 [0, 1] 的浮点数。它按通道顺序将像素值除以 255（如果是整数类型）或 1.0（如果是浮点数类型），以将像素值归一化到范围 [0, 1]。</p>
<p>举个例子，假设有一个 8-bit 的灰度图像，像素值范围在 [0, 255]。应用 <code>transforms.ToTensor()</code> 操作后，图像的像素值将被转换为浮点数类型，并归一化到范围 [0, 1]。</p>
<p>下面是一个示例来说明 <code>transforms.ToTensor()</code> 的使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载图像并创建 PIL 图像对象</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">"image.jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图像转换为张量形式</span></span><br><span class="line">to_tensor = transforms.ToTensor()</span><br><span class="line">tensor_img = to_tensor(img)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Original Image:\n"</span>, img)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Transformed Image:\n"</span>, tensor_img)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们首先加载图像并创建了一个 PIL 图像对象 <code>img</code>。然后，我们使用 <code>transforms.ToTensor()</code> 将图像转换为张量形式，并将结果存储在 <code>tensor_img</code> 中。最后，我们打印原始图像和转换后的张量形式。</p>
<p>需要注意的是，<code>transforms.ToTensor()</code> 只是将图像的数据类型进行转换和归一化，不会改变图像的尺寸或像素值本身。如果你希望对图像进行尺寸调整或其他变换，可以在转换流水线中添加相应的操作来实现。</p>
<h3 id="torch-distributions"><a href="#torch-distributions" class="headerlink" title="torch.distributions"></a>torch.distributions</h3><p><a target="_blank" rel="noopener" href="https://pytorch.org/docs/stable/distributions.html">documentation</a> </p>
<h4 id="torch-distributions-categorical-probs"><a href="#torch-distributions-categorical-probs" class="headerlink" title="torch.distributions.categorical(probs)"></a>torch.distributions.categorical(probs)</h4><p><code>class torch.distributions.categorical(probs)</code></p>
<p>其作用是创建以参数probs为标准的类别分布，样本是来自“0，…，K-1”的整数，K是probs参数的长度。也就是说，按照probs的概率，在相应的位置进行采样，采样返回的是该位置的整数索引。</p>
<p>如果probs是长度为K的一维列表，则每个元素是对该索引处的类进行采样的相对概率。</p>
<p>如果probs是二维的，它被视为一批概率向量</p>
<blockquote>
<p>NOTE：</p>
<p>输入为Logits，也就是说和可以不为1，但是它会自动会做<strong>归一化</strong></p>
<p>Logits是一个数值向量，用于表示分类模型中每个类别的得分或概率，通常表示为未归一化的原始输出。在机器学习中，logits通常是神经网络的最后一层输出，它们通过softmax函数进行归一化，得到每个类别的概率分布。在分类问题中，通过比较类别的logits得分，可以确定预测的类别是什么。Logits的大小和数量通常由特定的模型和任务决定，比如二分类任务中通常只有一个logit，而在多分类任务中则有多个logits，每个logit对应一个类别。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一维</span></span><br><span class="line">probs = torch.FloatTensor([<span class="number">0.9</span>,<span class="number">0.2</span>])</span><br><span class="line">D = Categorical(probs)</span><br><span class="line"><span class="built_in">print</span>(D)                  <span class="comment"># Categorical(probs: torch.Size([2]))</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(D.sample())         </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor(0)</span></span><br><span class="line"><span class="string">tensor(0)</span></span><br><span class="line"><span class="string">tensor(0)</span></span><br><span class="line"><span class="string">tensor(0)</span></span><br><span class="line"><span class="string">tensor(1)</span></span><br><span class="line"><span class="string"> '''</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#多维</span></span><br><span class="line"><span class="keyword">from</span> torch.distributions.categorical <span class="keyword">import</span> Categorical</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">probs = torch.FloatTensor([[<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.7</span>], [<span class="number">0.7</span>, <span class="number">0</span>, <span class="number">0.3</span>]])</span><br><span class="line">D = Categorical(probs)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(D.sample())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([2, 2])</span></span><br><span class="line"><span class="string">tensor([2, 0])</span></span><br><span class="line"><span class="string">tensor([2, 0])</span></span><br><span class="line"><span class="string">tensor([2, 2])</span></span><br><span class="line"><span class="string">tensor([2, 0])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 权重是0，在其他元素被取完之前是不会被取到的。</span></span><br></pre></td></tr></table></figure>
<p><strong>log_prob</strong></p>
<p><code>torch.distributions.categorical.log_prob</code>是PyTorch中用于计算分类分布的对数概率的函数。它接受两个参数：一个是<code>value</code>，表示要计算对数概率的离散取值；另一个是<code>probs</code>，表示分类分布的概率。函数将返回一个张量，其中包含每个取值的<strong>对数概率</strong>。</p>
<p>这个函数在训练神经网络时非常有用，可以用来计算交叉熵损失。交叉熵损失可以看作是真实标签与模型预测之间的KL散度，即它们之间的距离。在计算交叉熵时，需要用到<code>torch.distributions.categorical.log_prob</code>函数来计算模型对每个类别的预测概率，从而计算出损失值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一维</span></span><br><span class="line"><span class="keyword">from</span> torch.distributions.categorical <span class="keyword">import</span> Categorical</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">d = torch.tensor([<span class="number">0.3</span>,<span class="number">0.4</span>,<span class="number">0.5</span>])</span><br><span class="line">G = Categorical(d)</span><br><span class="line"><span class="comment"># print(G.sample())</span></span><br><span class="line"><span class="built_in">print</span>(G.log_prob(torch.tensor(<span class="number">2</span>))) <span class="comment"># tensor(-0.8755)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0.5/(0.3+0.4+0.5)=0.41666</span></span><br><span class="line"><span class="string">log(0.41666)=-0.87547033735517</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#多维</span></span><br><span class="line"><span class="keyword">from</span> torch.distributions.categorical <span class="keyword">import</span> Categorical</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">probs = torch.FloatTensor([[<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.7</span>], [<span class="number">0.7</span>, <span class="number">0</span>, <span class="number">0.3</span>]])</span><br><span class="line">D = Categorical(probs)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(D.log_prob(torch.tensor([<span class="number">1</span>,<span class="number">0</span>])))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([-1.6094, -0.3567])</span></span><br><span class="line"><span class="string">NOTE:</span></span><br><span class="line"><span class="string">log(0.2)=-1.60943791243</span></span><br><span class="line"><span class="string">log(0.7)=-0.35667494393</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p><strong>entropy()</strong></p>
<p>假设我们有一个分类问题，共有 5 个类别，每个类别的概率分别为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="46.457ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 20534.2 860"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mn" transform="translate(536,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1217.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2273.1,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(3551.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(3995.8,0)"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mn" transform="translate(536,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(5213.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(6268.9,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(7546.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(7991.6,0)"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mn" transform="translate(536,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="mo" transform="translate(9208.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(10264.7,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(11542.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(11987.3,0)"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mn" transform="translate(536,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mo" transform="translate(13204.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(14260.4,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(778,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1278,0)"></path></g><g data-mml-node="mo" transform="translate(16038.4,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(16483.1,0)"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mn" transform="translate(536,-150) scale(0.707)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g></g><g data-mml-node="mo" transform="translate(17700.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(18756.2,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(778,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1278,0)"></path></g></g></g></svg></mjx-container>。我们可以用PyTorch 的分布类 <code>torch.distributions.Categorical</code> 来表示这个概率分布，代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.distributions <span class="keyword">import</span> Categorical</span><br><span class="line"></span><br><span class="line">p = torch.tensor([<span class="number">0.3</span>, <span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">0.15</span>, <span class="number">0.25</span>])</span><br><span class="line">pi = Categorical(probs=p)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，我们用 <code>Categorical</code> 类初始化了一个分布对象 <code>pi</code>，并将概率向量 <code>p</code> 作为参数传入。现在，我们可以通过调用 <code>pi.entropy()</code> 方法来计算这个分布的熵：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entropy = pi.entropy()</span><br><span class="line"><span class="built_in">print</span>(entropy)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行代码后，输出的结果是一个张量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor(<span class="number">1.6094</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个数值就是我们要求的熵。我们可以使用公式 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.663ex;" xmlns="http://www.w3.org/2000/svg" width="20.969ex" height="2.36ex" role="img" focusable="false" viewBox="0 -750 9268.1 1043.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1277,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(1780,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2446.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(3502.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="munder" transform="translate(4447.2,0)"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"></path></g><g data-mml-node="mi" transform="translate(1089,-285.4) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="msub" transform="translate(5996.8,0)"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mi" transform="translate(536,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mi" transform="translate(6993.5,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(8271.5,0)"><path data-c="2061" d=""></path></g><g data-mml-node="msub" transform="translate(8438.1,0)"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mi" transform="translate(536,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container> 来手动计算这个熵值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entropy_manual = -(p * torch.log(p)).<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(entropy_manual)</span><br></pre></td></tr></table></figure>
<p>运行代码后，输出的结果也是 1.6094。可以看到，两种方法计算出的结果是一样的。</p>
<p>需要注意的是，熵的单位通常是比特（bit）或者纳特（nat），可以理解为信息量的度量单位。在上面的例子中，我们使用的是比特作为单位，因为 PyTorch 默认使用的就是比特。如果要将熵转换为纳特，可以将结果除以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="3.395ex" height="1.57ex" role="img" focusable="false" viewBox="0 -694 1500.7 694"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"></path></g><g data-mml-node="mo" transform="translate(834,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mn" transform="translate(1000.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container>。</p>
<h4 id="torch-distributions-normal-Normal"><a href="#torch-distributions-normal-Normal" class="headerlink" title="torch.distributions.normal.Normal"></a>torch.distributions.normal.Normal</h4><p><code>torch.distributions.normal.Normal</code> 是 PyTorch 中用于表示正态分布的概率分布对象。可以使用它来生成正态分布的样本，计算正态分布的概率密度函数、对数概率密度函数以及采样的对数概率等等。</p>
<p><code>torch.distributions.normal.Normal</code> 接受两个参数：</p>
<ul>
<li><code>loc</code>：正态分布的均值。</li>
<li><code>scale</code>：正态分布的标准差。</li>
</ul>
<p>创建一个 <code>Normal</code> 分布对象示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.distributions.normal <span class="keyword">import</span> Normal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个正态分布对象</span></span><br><span class="line">mu, sigma = <span class="number">0</span>, <span class="number">1</span>  <span class="comment"># 均值和标准差</span></span><br><span class="line">normal_distribution = Normal(mu, sigma)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机样本</span></span><br><span class="line">samples = normal_distribution.sample(sample_shape=(<span class="number">3</span>,))  <span class="comment"># 生成3个样本</span></span><br><span class="line"><span class="built_in">print</span>(samples)  <span class="comment"># tensor([ 0.6784, -0.4065,  1.4159])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算概率密度函数</span></span><br><span class="line">x = torch.tensor([<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>])</span><br><span class="line">pdf = normal_distribution.log_prob(x)</span><br><span class="line"><span class="built_in">print</span>(pdf)  <span class="comment"># tensor([-0.9189, -1.4189, -2.9189])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们先创建了一个正态分布对象 <code>normal_distribution</code>。然后，使用 <code>sample</code> 方法从该分布中生成了 3 个随机样本。最后，使用 <code>log_prob</code> 方法计算了正态分布在 <code>x=[0, 1, 2]</code> 处的对数概率密度函数，并将结果存储在变量 <code>pdf</code> 中。</p>
<p>除了上述方法，还有很多其他的用法。例如，可以使用 <code>rsample()</code> 方法生成重参数化样本，使用 <code>entropy()</code> 方法计算分布的熵等等。</p>
<p><strong>entropy</strong></p>
<p>假设我们有一个均值为 0，标准差为 1 的正态分布，可以用如下代码来初始化一个分布对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.distributions <span class="keyword">import</span> Normal</span><br><span class="line"></span><br><span class="line">mu = <span class="number">0.0</span>  <span class="comment"># 均值</span></span><br><span class="line">sigma = <span class="number">1.0</span>  <span class="comment"># 标准差</span></span><br><span class="line">pi = Normal(mu, sigma)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，我们可以使用 <code>pi.entropy()</code> 方法来计算这个分布的熵：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entropy = pi.entropy()</span><br><span class="line"><span class="built_in">print</span>(entropy)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出的结果应该是一个张量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor(<span class="number">1.4189</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，对于正态分布来说，熵并没有一个封闭式的表达式，因此 <code>pi.entropy()</code> 方法的实现是通过数值积分的方式进行估计的。这个估计值的精度取决于分布的参数，以及数值积分的参数等因素，可能会有一定的误差。同时，由于正态分布是连续分布，熵的单位通常是比特/样本（bits/sample）或者纳特/样本（nats/sample），表示每个样本上平均的信息熵。如果要将熵转换为比特/样本，可以将结果除以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.466ex;" xmlns="http://www.w3.org/2000/svg" width="4.4ex" height="2.036ex" role="img" focusable="false" viewBox="0 -694 1944.7 900"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(1278,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mn" transform="translate(1444.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container>。</p>
<h3 id="torch-as-tensor"><a href="#torch-as-tensor" class="headerlink" title="torch.as_tensor()"></a>torch.as_tensor()</h3><p><code>torch.as_tensor(data, dtype=None,device=None)-&gt;Tensor</code> : 为data生成tensor。</p>
<p>如果data已经是tensor，且dtype和device与参数相同，则生成的tensor会和data共享内存。如果data是ndarray,且dtype对应，devices为cpu，则同样共享内存。其他情况则不共享内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">a = numpy.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">t = torch.as_tensor(a)</span><br></pre></td></tr></table></figure>
<h3 id="count-vars-module"><a href="#count-vars-module" class="headerlink" title="count_vars(module):"></a>count_vars(module):</h3><p>自定义函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_vars</span>(<span class="params">module</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>([np.prod(p.shape) <span class="keyword">for</span> p <span class="keyword">in</span> module.parameters()])</span><br></pre></td></tr></table></figure>
<p>这段代码用于计算一个PyTorch模型中的变量数量。让我逐步解释它的功能：</p>
<ol>
<li><code>module.parameters()</code>：这是一个PyTorch模块中的方法，返回该模块的所有可学习参数的迭代器。可学习参数是指在模型训练过程中需要进行优化的参数，例如权重和偏置项。</li>
<li><code>[np.prod(p.shape) for p in module.parameters()]</code>：这是一个列表推导式，用于遍历模块中的每个参数并计算其形状（shape）的总元素数量。<code>p.shape</code>返回参数p的形状，而<code>np.prod()</code>函数用于计算形状中所有元素的乘积，即参数的总数量。</li>
<li><code>sum([...])</code>：最后，使用<code>sum()</code>函数将列表中的所有参数数量相加，得到总的变量数量。</li>
</ol>
<p>因此，<code>count_vars(module)</code>函数返回了给定模块中所有可学习参数的总数量。这对于了解模型的规模和复杂性非常有用，特别是在调试和优化模型时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(SimpleModel, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">model = SimpleModel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_vars</span>(<span class="params">module</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>([np.prod(p.shape) <span class="keyword">for</span> p <span class="keyword">in</span> module.parameters()])</span><br><span class="line"></span><br><span class="line">num_vars = count_vars(model)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Total variables in the model:"</span>, num_vars)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Total variables in the model: 67</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们应用<code>count_vars(module)</code>函数来计算模型中的变量数量时，它会经历以下步骤：</p>
<ol>
<li><code>module.parameters()</code>返回一个迭代器，包含了模型<code>module</code>中的所有可学习参数。</li>
<li>利用列表推导式 <code>[np.prod(p.shape) for p in module.parameters()]</code>，我们遍历了每个参数<code>p</code>并计算了其形状的总元素数量。<ul>
<li>对于<code>SimpleModel</code>中的第一个全连接层<code>self.fc1</code>，它具有形状为 <code>(5, 10)</code> 的权重参数和形状为 <code>(5,)</code> 的偏置项参数。因此，权重参数的元素数量为 <code>5 * 10 = 50</code>，偏置项参数的元素数量为 <code>5</code>。</li>
<li>对于<code>SimpleModel</code>中的第二个全连接层<code>self.fc2</code>，它具有形状为 <code>(2, 5)</code> 的权重参数和形状为 <code>(2,)</code> 的偏置项参数。因此，权重参数的元素数量为 <code>2 * 5 = 10</code>，偏置项参数的元素数量为 <code>2</code>。</li>
</ul>
</li>
<li>接下来，我们将列表中的所有参数数量相加，使用<code>sum()</code>函数计算得到总的变量数量。<ul>
<li>在这个例子中，总变量数量为 <code>50 + 5 + 10 + 2 = 67</code>。</li>
</ul>
</li>
<li>最后，函数<code>count_vars(module)</code>返回计算得到的总变量数量。</li>
</ol>
<p>通过这个计算过程，我们可以得到模型中所有可学习参数的总数量。在这个例子中，模型<code>SimpleModel</code>中的总变量数量为67。</p>
<h3 id="permute"><a href="#permute" class="headerlink" title="permute"></a>permute</h3><p>在PyTorch中，<code>permute</code>是一个用于维度重排的函数。它可以用来改变张量的维度顺序，从而实现维度的重排和转置操作。</p>
<p><code>permute</code>函数的语法如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">permuted_tensor = tensor.permute(*dims)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，<code>tensor</code>是要进行维度重排的张量，<code>dims</code>是一个元组或列表，用于指定新的维度顺序。<code>dims</code>中的每个元素表示原始张量中对应维度的索引位置。</p>
<p>下面是一个简单的示例，演示如何使用<code>permute</code>函数进行维度重排：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个张量</span></span><br><span class="line">x = torch.arange(<span class="number">24</span>).reshape((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用permute进行维度重排</span></span><br><span class="line">y = x.permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"原始张量 x:\n"</span>,x,x.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"维度重排后的张量 y:\n"</span>, y,y.shape)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">原始张量 x:</span><br><span class="line"> tensor([[[ 0,  1,  2,  3],</span><br><span class="line">         [ 4,  5,  6,  7],</span><br><span class="line">         [ 8,  9, 10, 11]],</span><br><span class="line"></span><br><span class="line">        [[12, 13, 14, 15],</span><br><span class="line">         [16, 17, 18, 19],</span><br><span class="line">         [20, 21, 22, 23]]]) torch.Size([2, 3, 4])</span><br><span class="line">维度重排后的张量 y:</span><br><span class="line"> tensor([[[ 0,  4,  8],</span><br><span class="line">         [12, 16, 20]],</span><br><span class="line"></span><br><span class="line">        [[ 1,  5,  9],</span><br><span class="line">         [13, 17, 21]],</span><br><span class="line"></span><br><span class="line">        [[ 2,  6, 10],</span><br><span class="line">         [14, 18, 22]],</span><br><span class="line"></span><br><span class="line">        [[ 3,  7, 11],</span><br><span class="line">         [15, 19, 23]]]) torch.Size([4, 2, 3])</span><br></pre></td></tr></table></figure>
<p>原始张量 <code>x</code> 相比发生了变化。<code>x</code> 的维度顺序为 <code>(2, 3, 4)</code>，而 <code>y</code> 的维度顺序为 <code>(4, 2, 3)</code>，即原始张量 <code>x</code> 的第一个维度变成了 <code>y</code> 的最后一个维度，第二个维度变成了 <code>y</code> 的第一个维度，第三个维度变成了 <code>y</code> 的第二个维度。</p>
<p>通过使用 <code>permute</code> 函数，我们可以方便地对张量的维度顺序进行灵活的调整，适应不同的计算需求。在深度学习中，这对于数据的预处理和模型的输入处理非常有用。</p>
<h3 id="set-printoptions"><a href="#set-printoptions" class="headerlink" title="set_printoptions"></a>set_printoptions</h3><p>在PyTorch中，<code>torch.set_printoptions()</code>函数用于设置张量的打印选项，以控制张量打印时的显示方式。</p>
<p>具体到 <code>torch.set_printoptions(2)</code>，它是用来设置张量打印时浮点数的小数点后保留的位数。</p>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.tensor([<span class="number">0.123456789</span>])</span><br><span class="line"></span><br><span class="line">torch.set_printoptions(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 打印张量 x</span></span><br><span class="line"></span><br><span class="line">torch.set_printoptions(precision=<span class="literal">None</span>)  <span class="comment"># 恢复默认设置</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 再次打印张量 x</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([0.12])</span></span><br><span class="line"><span class="string">tensor([0.1235])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们首先创建了一个包含单个浮点数的张量 <code>x</code>。然后，通过 <code>torch.set_printoptions(2)</code> 将打印选项设置为保留两位小数。</p>
<p>在第一次打印张量 <code>x</code> 时，只有两位小数是可见的，即 <code>0.12</code>。这是因为我们使用 <code>torch.set_printoptions(2)</code> 设置了小数点后保留两位。</p>
<p>然后，我们使用 <code>torch.set_printoptions(precision=None)</code> 恢复了默认的打印选项。在第二次打印张量 <code>x</code> 时，显示了更多位数的小数，即 <code>0.1235</code>。</p>
<p>通过使用 <code>torch.set_printoptions()</code> 函数，我们可以灵活地控制张量打印时的显示方式，包括小数点位数、科学计数法等。这对于调试、输出结果观察和数据分析非常有用。</p>
<h3 id="torch-cat"><a href="#torch-cat" class="headerlink" title="torch.cat"></a>torch.cat</h3><p><code>torch.cat()</code> 是 PyTorch 中用于进行张量拼接（连接）操作的函数。它可以将多个张量按照指定的维度进行拼接，生成一个新的张量。</p>
<p>函数的基本用法是 <code>torch.cat(tensors, dim=0, *, out=None)</code>，其中参数的含义如下：</p>
<ul>
<li><code>tensors</code>：要拼接的张量序列，可以是一个包含多个张量的列表或元组。</li>
<li><code>dim</code>：指定拼接的维度（轴）。默认为0，表示在第一个维度（行）上进行拼接。</li>
<li><code>out</code>：可选参数，用于指定输出张量，如果不提供，则会创建一个新的张量来存储结果。</li>
</ul>
<p><code>torch.cat()</code> 函数通过指定的维度 <code>dim</code> 将多个张量连接在一起。在拼接过程中，除了指定的维度之外，其他维度的大小必须相同。</p>
<p>以下是一些常见的用法示例：</p>
<p><strong>1. 拼接行向量</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = torch.tensor([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">result = torch.cat([a, b], dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># tensor([1, 2, 3, 4, 5, 6])</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 拼接列向量</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.tensor([[<span class="number">1</span>],</span><br><span class="line">                  [<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">b = torch.tensor([[<span class="number">4</span>],</span><br><span class="line">                  [<span class="number">5</span>],</span><br><span class="line">                  [<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result1 = torch.cat([a, b], dim=<span class="number">0</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[1],</span></span><br><span class="line"><span class="string">        [2],</span></span><br><span class="line"><span class="string">        [3],</span></span><br><span class="line"><span class="string">        [4],</span></span><br><span class="line"><span class="string">        [5],</span></span><br><span class="line"><span class="string">        [6]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">result2 = torch.cat([a, b], dim=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[1, 4],</span></span><br><span class="line"><span class="string">        [2, 5],</span></span><br><span class="line"><span class="string">        [3, 6]])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>3. 拼接多个矩阵</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">                  [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line">b = torch.tensor([[<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                  [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">c = torch.tensor([[<span class="number">9</span>, <span class="number">10</span>],</span><br><span class="line">                  [<span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">result = torch.cat([a, b, c], dim=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensor([[ 1,  2,  5,  6,  9, 10],</span></span><br><span class="line"><span class="string">        [ 3,  4,  7,  8, 11, 12]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们拼接了三个矩阵 <code>a</code>、<code>b</code> 和 <code>c</code>，并沿着列维度 <code>dim=1</code> 进行拼接。注意，要保证除拼接维度之外的其他维度大小相同，以便能够进行拼接操作。</p>
<p><code>torch.cat()</code> 函数的灵活性使得它可以在各种情况下使用，从拼接向量到拼接多维张量。它是在处理需要组合多个张量的问题时非常有用的工具。</p>
<h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="iloc-amp-loc"><a href="#iloc-amp-loc" class="headerlink" title="iloc&loc"></a>iloc&amp;loc</h4><p>Pandas中的<code>loc</code>和<code>iloc</code>都是用于访问和修改DataFrame或Series中的元素，二者主要的区别在于索引方式不同。</p>
<p><code>loc</code>使用的是基于标签的索引方式，即通过行标签或列标签进行索引，包括对索引标签的切片操作，它的语法结构为<code>df.loc[row_indexer, column_indexer]</code>。其中<code>row_indexer</code>和<code>column_indexer</code>可以是标签的单个值、标签的列表或标签的切片。例如，<code>df.loc[2, 'name']</code>表示选取第2行、’name’列的元素，<code>df.loc[[1, 3, 5], ['name', 'age']]</code>表示选取第1、3、5行，’name’、’age’列的元素。</p>
<p><code>iloc</code>使用的是基于位置的索引方式，即通过行号或列号进行索引，也包括对位置的切片操作，它的语法结构为<code>df.iloc[row_indexer, column_indexer]</code>。其中<code>row_indexer</code>和<code>column_indexer</code>可以是整数的单个值、整数的列表或整数的切片。例如，<code>df.iloc[2, 1]</code>表示选取第3行、第2列的元素，<code>df.iloc[[1, 3, 5], [0, 2]]</code>表示选取第2、4、6行，第1、3列的元素。</p>
<p>总的来说，<code>loc</code>是基于标签的索引方式，适用于标签具有实际意义的场合，如索引是时间序列或者字符串时；而<code>iloc</code>是基于位置的索引方式，适用于数据集没有标签或者标签没有实际意义的场合，如行号和列号等。</p>
<p>假设有如下的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	name  age  gender</span><br><span class="line"><span class="number">0</span>   Tom   <span class="number">20</span>    male</span><br><span class="line"><span class="number">1</span>  Lucy   <span class="number">22</span>  female</span><br><span class="line"><span class="number">2</span>  John   <span class="number">25</span>    male</span><br><span class="line"><span class="number">3</span>  Lily   <span class="number">18</span>  female</span><br></pre></td></tr></table></figure>
<p>如果我们想要选取第2行、’name’列的元素，可以使用<code>loc</code>和<code>iloc</code>两种方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataFrame</span></span><br><span class="line">data = {<span class="string">'name'</span>: [<span class="string">'Tom'</span>, <span class="string">'Lucy'</span>, <span class="string">'John'</span>, <span class="string">'Lily'</span>], <span class="string">'age'</span>: [<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">18</span>], <span class="string">'gender'</span>: [<span class="string">'male'</span>, <span class="string">'female'</span>, <span class="string">'male'</span>, <span class="string">'female'</span>]}</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取第2行、'name'列的元素</span></span><br><span class="line"><span class="comment"># loc方式</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="number">1</span>, <span class="string">'name'</span>])  <span class="comment"># 输出：Lucy</span></span><br><span class="line"><span class="comment"># iloc方式</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">1</span>, <span class="number">0</span>])  <span class="comment"># 输出：Lucy</span></span><br></pre></td></tr></table></figure>
<p>如果我们想要选取第1、3行，’name’、’age’列的元素，可以使用<code>loc</code>和<code>iloc</code>两种方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataFrame</span></span><br><span class="line">data = {<span class="string">'name'</span>: [<span class="string">'Tom'</span>, <span class="string">'Lucy'</span>, <span class="string">'John'</span>, <span class="string">'Lily'</span>], <span class="string">'age'</span>: [<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">18</span>], <span class="string">'gender'</span>: [<span class="string">'male'</span>, <span class="string">'female'</span>, <span class="string">'male'</span>, <span class="string">'female'</span>]}</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选取第1、3行，'name'、'age'列的元素</span></span><br><span class="line"><span class="comment"># loc方式</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="number">0</span>, <span class="number">2</span>], [<span class="string">'name'</span>, <span class="string">'age'</span>]])  </span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#   name  age</span></span><br><span class="line"><span class="comment"># 0   Tom   20</span></span><br><span class="line"><span class="comment"># 2  John   25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># iloc方式</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#   name  age</span></span><br><span class="line"><span class="comment"># 0   Tom   20</span></span><br><span class="line"><span class="comment"># 2  John   25</span></span><br></pre></td></tr></table></figure>
<h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a><strong><code>drop</code></strong></h4><p>功能：删除数据集中多余的数据</p>
<p><code>DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise')</code></p>
<p>常用参数详解：</p>
<p>labels:待删除的行名or列名；<br>axis:删除时所参考的轴，0为行，1为列；<br>index:待删除的行名<br>columns:待删除的列名<br>level:多级列表时使用，暂时不作说明<br>inplace:布尔值，默认为False,这是返回的是一个copy;若为True,返回的是删除相应数据后的版本<br>errors一般用不到，这里不作解释</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构件一个数据集</span></span><br><span class="line">df1=pd.DataFrame(np.arange(<span class="number">36</span>).reshape(<span class="number">6</span>,<span class="number">6</span>),columns=<span class="built_in">list</span>(<span class="string">'ABCDEF'</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202303210939049.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1.删除行数据'</span></span><br><span class="line"><span class="comment">#下面两种删除方式是等价的，传入labels和axis 与只传入一个index 作用相同</span></span><br><span class="line">df2=df1.drop(labels=<span class="number">0</span>,axis=<span class="number">0</span>)</span><br><span class="line">df22=df1.drop(index=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202303210950198.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除多行数据</span></span><br><span class="line">df3=df1.drop(labels=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],axis=<span class="number">0</span>)</span><br><span class="line">df33=df1.drop(index=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202303211002108.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'2.删除列数据'</span></span><br><span class="line">df4=df1.drop(labels=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>],axis=<span class="number">1</span>)</span><br><span class="line">df44=df1.drop(columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202303211002744.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'3.inplace参数的使用'</span></span><br><span class="line">dfs=df1</span><br><span class="line"><span class="comment">#inplace=None时返回删除前的数据</span></span><br><span class="line">dfs.drop(labels=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>],axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202303211003664.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#inplace=True时返回删除后的数据</span></span><br><span class="line">dfs.drop(labels=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202303211003446.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'4.drop函数在多级列表中的应用（实例copy自pandas官方帮助文档）‘</span></span><br><span class="line"><span class="string">#构建多级索引</span></span><br><span class="line"><span class="string">midx = pd.MultiIndex(levels=[['</span>lama<span class="string">', '</span>cow<span class="string">', '</span>falcon<span class="string">'],</span></span><br><span class="line"><span class="string">                             ['</span>speed<span class="string">', '</span>weight<span class="string">', '</span>length<span class="string">']],</span></span><br><span class="line"><span class="string">                     codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2],</span></span><br><span class="line"><span class="string">                            [0, 1, 2, 0, 1, 2, 0, 1, 2]])</span></span><br><span class="line"><span class="string">#构造数据集</span></span><br><span class="line"><span class="string">df = pd.DataFrame(index=midx, columns=['</span>big<span class="string">', '</span>small<span class="string">'],</span></span><br><span class="line"><span class="string">                  data=[[45, 30], [200, 100], [1.5, 1], [30, 20],</span></span><br><span class="line"><span class="string">                        [250, 150], [1.5, 0.8], [320, 250],</span></span><br><span class="line"><span class="string">                        [1, 0.8], [0.3, 0.2]])</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202303211003624.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同时删除行数据和列数据</span></span><br><span class="line">df.drop(index=<span class="string">'cow'</span>, columns=<span class="string">'small'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202303211004316.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除某级index的对应行</span></span><br><span class="line">df.drop(index=<span class="string">'length'</span>,level=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202303211004793.png" alt="img"></p>
<h4 id="fillna"><a href="#fillna" class="headerlink" title="fillna"></a><code>fillna</code></h4><p><code>fillna(value=None, method=None, axis=None, inplace=False,limit=None, downcast=None, **kwargs)</code></p>
<ul>
<li><code>value</code>：用于填充的<code>数值</code>。</li>
<li><code>method</code>：表示<code>填充方式</code>，默认值为None。</li>
<li><code>limit</code>： 可以连续填充的<code>最大数量</code>，默认None。</li>
</ul>
<blockquote>
<p><code>method</code>参数不能与<code>value</code>参数同时使用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame([[np.nan, <span class="number">2</span>, np.nan, <span class="number">0</span>],</span><br><span class="line">                   [<span class="number">3</span>, <span class="number">4</span>, np.nan, <span class="number">1</span>],</span><br><span class="line">                   [np.nan, np.nan, np.nan, <span class="number">5</span>],</span><br><span class="line">                   [np.nan, <span class="number">3</span>, np.nan, <span class="number">4</span>]],</span><br><span class="line">                  columns=<span class="built_in">list</span>(<span class="string">"ABCD"</span>))</span><br><span class="line">df</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">	A	B	C	D</span></span><br><span class="line"><span class="string">0	NaN	2.0	NaN	0</span></span><br><span class="line"><span class="string">1	3.0	4.0	NaN	1</span></span><br><span class="line"><span class="string">2	NaN	NaN	NaN	5</span></span><br><span class="line"><span class="string">3	NaN	3.0	NaN	4</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">a_mean = df[<span class="string">'A'</span>].mean()</span><br><span class="line">b_mean = df[<span class="string">'B'</span>].mean()</span><br><span class="line">c_mean = df[<span class="string">'C'</span>].mean()</span><br><span class="line">df.fillna({<span class="string">'A'</span>:a_mean,<span class="string">'B'</span>:b_mean,<span class="string">"C"</span>:c_mean},inplace=<span class="literal">True</span>)</span><br><span class="line">df</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">	A	B	C	D</span></span><br><span class="line"><span class="string">0	3.0	2.0	NaN	0</span></span><br><span class="line"><span class="string">1	3.0	4.0	NaN	1</span></span><br><span class="line"><span class="string">2	3.0	3.0	NaN	5</span></span><br><span class="line"><span class="string">3	3.0	3.0	NaN	4</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="get-dummies"><a href="#get-dummies" class="headerlink" title="get_dummies"></a><code>get_dummies</code></h4><p>pd.get_dummies() 是 Pandas 的一个函数，它在一行代码中执行伪编码。数据科学家大多将其用于特征编码，但不建议将其用于生产或 Kaggle 竞赛。</p>
<p>==测试数据可能具有也可能不具有所有特征值，这可能会在建模时导致数据不匹配问题。==</p>
<p>pandas的get_dummies函数可以将分类数据转换为二进制哑变量（dummy variable）表示形式，方便机器学习和数据分析的处理。下面是get_dummies函数的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.get_dummies(data, prefix=<span class="literal">None</span>, prefix_sep=<span class="string">'_'</span>, dummy_na=<span class="literal">False</span>, columns=<span class="literal">None</span>, sparse=<span class="literal">False</span>, drop_first=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>其中，参数说明如下：</p>
<ul>
<li><code>data</code>：要进行处理的DataFrame或Series对象。</li>
<li><code>prefix</code>：哑变量的列名前缀，用于与原始列进行区分。默认值为None，表示使用原始列名作为前缀。</li>
<li><code>prefix_sep</code>：前缀与列名的分隔符，默认值为下划线。</li>
<li><code>dummy_na</code>：是否为缺失值创建一列哑变量，如果为True，则将缺失值所在行的哑变量值设为1。默认值为False。</li>
<li><code>columns</code>：指定要进行哑变量转换的列，如果不指定，则默认对所有的分类数据进行处理。</li>
<li><code>sparse</code>：是否返回稀疏矩阵（SparseDataFrame），默认为False，表示返回密集矩阵（DataFrame）。</li>
<li><code>drop_first</code>：是否删除第一个哑变量列，默认为False，表示保留第一个哑变量列。</li>
<li><code>dtype</code>：指定输出矩阵的数据类型，默认为np.uint8。</li>
</ul>
<p>下面是一个示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.DataFrame({<span class="string">'color'</span>: [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'red'</span>, <span class="string">'blue'</span>]})</span><br><span class="line">dummies = pd.get_dummies(data[<span class="string">'color'</span>], prefix=<span class="string">'color'</span>)</span><br><span class="line">data = pd.concat([data, dummies], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   color  color_blue  color_green  color_red</span><br><span class="line">0    red           0            0          1</span><br><span class="line">1  green           0            1          0</span><br><span class="line">2   blue           1            0          0</span><br><span class="line">3    red           0            0          1</span><br><span class="line">4   blue           1            0          0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该示例代码将一列分类数据“color”转换为了三列哑变量数据，并将它们与原始数据进行合并。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.DataFrame({<span class="string">'color'</span>: [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'red'</span>, <span class="string">'blue'</span>],<span class="string">'age'</span>:[<span class="number">12</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]})</span><br><span class="line">data = pd.get_dummies(data)</span><br><span class="line"><span class="comment"># data = pd.concat([data, dummies], axis=1)</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   age  color_blue  color_green  color_red</span><br><span class="line">0   12           0            0          1</span><br><span class="line">1    3           0            1          0</span><br><span class="line">2    4           1            0          0</span><br><span class="line">3    5           0            0          1</span><br><span class="line">4    6           1            0          0</span><br></pre></td></tr></table></figure>
<h4 id="to-numeric"><a href="#to-numeric" class="headerlink" title="to_numeric"></a><strong>to_numeric</strong></h4><p><code>pandas.to_numeric()</code>是一个用于将Pandas对象（Series或DataFrame）中的数据转换为数值类型的函数。这个函数的语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pandas.to_numeric(arg, errors=<span class="string">'raise'</span>, downcast=<span class="literal">None</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，<code>arg</code>表示需要转换的Pandas对象，可以是一个Series或DataFrame，或是一个由Series或DataFrame构成的列表或字典；<code>errors</code>表示非数值数据的处理方式，它有以下几个选项：</p>
<ul>
<li><code>'raise'</code>（默认值）：如果有非数值数据，就抛出异常；</li>
<li><code>'coerce'</code>：如果有非数值数据，就将它们转换为NaN；</li>
<li><code>'ignore'</code>：忽略非数值数据，不进行转换；</li>
</ul>
<p><code>downcast</code>表示转换后的数据类型，它可以是以下几个选项：</p>
<ul>
<li><code>'integer'</code>：将数值类型转换为整型；</li>
<li><code>'signed'</code>：将数值类型转换为带符号的整型；</li>
<li><code>'unsigned'</code>：将数值类型转换为无符号的整型；</li>
<li><code>'float'</code>：将数值类型转换为浮点型；</li>
</ul>
<p>如果不指定<code>downcast</code>，则会根据转换后的数值类型自动选择合适的数据类型。</p>
<p>下面是一个示例代码，演示如何使用<code>pandas.to_numeric()</code>将Pandas对象中的数据转换为数值类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含非数值数据的Series</span></span><br><span class="line">s = pd.Series([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3a'</span>, <span class="string">'4b'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将Series中的数据转换为数值类型</span></span><br><span class="line">s = pd.to_numeric(s, errors=<span class="string">'coerce'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0    1.0</span></span><br><span class="line"><span class="string">1    2.0</span></span><br><span class="line"><span class="string">2    3.0</span></span><br><span class="line"><span class="string">3    4.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 创建一个包含非数字元素的DataFrame</span></span><br><span class="line">df = pd.DataFrame({<span class="string">'A'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'B'</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="string">'fdfd'</span>]})</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列B中的非数字元素替换为NaN</span></span><br><span class="line">df[<span class="string">'B'</span>] = pd.to_numeric(df[<span class="string">'B'</span>], errors=<span class="string">'coerce'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">   A    B</span></span><br><span class="line"><span class="string">0  1  4.0</span></span><br><span class="line"><span class="string">1  2  5.0</span></span><br><span class="line"><span class="string">2  3  NaN</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们使用<code>pd.to_numeric()</code>方法将Series中的数据转换为数值类型。由于Series中包含非数值数据，我们将<code>errors</code>参数设置为<code>'coerce'</code>，将非数值数据转换为NaN。最后，我们输出了处理后的Series。</p>
<p>需要注意的是，<code>pandas.to_numeric()</code>方法不能处理多个特征的情况，如果要处理多个特征，需要对每个特征进行单独的转换。另外，如果要将某一列中的非数字元素替换为指定的值，可以使用<code>replace()</code>方法。</p>
<h4 id="select-dtypes"><a href="#select-dtypes" class="headerlink" title="select_dtypes"></a><code>select_dtypes</code></h4><p>找到特定类型的列，返回一个索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data.select_dtypes(<span class="string">'object'</span>).columns</span><br></pre></td></tr></table></figure>
<h4 id="dtypes"><a href="#dtypes" class="headerlink" title="dtypes"></a>dtypes</h4><p>在 pandas 中，<code>train_data.dtypes</code> 是一个 Series 对象，它存储了 DataFrame 中每个列的数据类型。而 <code>train_data.dtypes != 'object'</code> 则是一个条件判断，它会返回一个布尔类型的 Series 对象，其中每个元素的值表示对应列的数据类型是否不为字符串类型（即不是 object 类型）。</p>
<p>综合起来，<code>train_data.dtypes[train_data.dtypes != 'object']</code> 表示在 DataFrame <code>train_data</code> 中，选择所有数据类型不是字符串类型的列，并返回一个 Series 对象，其中包含了这些列的数据类型。通常情况下，这样的操作可以用来选取非文本类型的列，以便进行数据分析或机器学习模型训练等操作。</p>
<p>以下代码：将特征分为数字特征和字符特征</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">train_data.dtypes</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Address                         object</span></span><br><span class="line"><span class="string">Sold Price                     float64</span></span><br><span class="line"><span class="string">Summary                         object</span></span><br><span class="line"><span class="string">Type                            object</span></span><br><span class="line"><span class="string">Year built                     float64</span></span><br><span class="line"><span class="string">Heating                         object</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">train_data.dtypes != <span class="string">'object'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Address                        False</span></span><br><span class="line"><span class="string">Sold Price                      True</span></span><br><span class="line"><span class="string">Summary                        False</span></span><br><span class="line"><span class="string">Type                           False</span></span><br><span class="line"><span class="string">Year built                      True</span></span><br><span class="line"><span class="string">Heating                        False</span></span><br><span class="line"><span class="string">Cooling                        False</span></span><br><span class="line"><span class="string">Parking                        False</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">train_data.dtypes[train_data.dtypes != <span class="string">'object'</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Sold Price                     float64</span></span><br><span class="line"><span class="string">Year built                     float64</span></span><br><span class="line"><span class="string">Lot                            float64</span></span><br><span class="line"><span class="string">Bathrooms                      float64</span></span><br><span class="line"><span class="string">Full bathrooms                 float64</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">numeric_features = train_data.dtypes[train_data.dtypes != <span class="string">'object'</span>].index</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Index(['Sold Price', 'Year built', 'Lot', 'Bathrooms', 'Full bathrooms',</span></span><br><span class="line"><span class="string">       'Total interior livable area', 'Total spaces', 'Garage spaces',</span></span><br><span class="line"><span class="string">       'Elementary School Score', 'Elementary School Distance',</span></span><br><span class="line"><span class="string">       'Middle School Score', 'Middle School Distance', 'High School Score',</span></span><br><span class="line"><span class="string">       'High School Distance', 'Tax assessed value', 'Annual tax amount',</span></span><br><span class="line"><span class="string">       'Listed Price', 'Last Sold Price', 'Zip'],</span></span><br><span class="line"><span class="string">      dtype='object')</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numeric_features = train_data.dtypes[train_data.dtypes != <span class="string">'object'</span>].index</span><br><span class="line">obj_features = train_data.dtypes[train_data.dtypes == <span class="string">'object'</span>].index</span><br><span class="line"></span><br><span class="line">train_num = train_data[numeric_features]</span><br><span class="line">train_obj = train_data[obj_features]</span><br></pre></td></tr></table></figure>
<h4 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h4><p>使用<code>Pandas</code>中的<code>groupby</code>函数将具有相同特征的行分组，并使用<code>mean</code>函数计算每个组的平均值。假设您有一个名为<code>df</code>的数据框，其中包含要分组的特征列和要平均的值列，您可以按如下方式将具有相同特征的行取平均：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建示例数据框</span></span><br><span class="line">df = pd.DataFrame({<span class="string">'姓名'</span>: [<span class="string">'小明'</span>, <span class="string">'小红'</span>, <span class="string">'小明'</span>, <span class="string">'小红'</span>],</span><br><span class="line">                   <span class="string">'性别'</span>: [<span class="string">'男'</span>, <span class="string">'女'</span>, <span class="string">'男'</span>, <span class="string">'女'</span>],</span><br><span class="line">                   <span class="string">'年龄'</span>: [<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">26</span>],</span><br><span class="line">                   <span class="string">'成绩'</span>: [<span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]})</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p><img src="C:/Users/auroras/AppData/Roaming/Typora/typora-user-images/image-20230414103230899.png" alt="image-20230414103230899" style="zoom:50%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[[<span class="string">'姓名'</span>,<span class="string">'性别'</span>,<span class="string">'成绩'</span>]].groupby([<span class="string">'姓名'</span>,<span class="string">'性别'</span>]).mean()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202304141033649.png" alt="image-20230414103302584" style="zoom:50%;"></p>
<h4 id="pandas怎某一列特征的值将数据集分为两部分"><a href="#pandas怎某一列特征的值将数据集分为两部分" class="headerlink" title="pandas怎某一列特征的值将数据集分为两部分"></a>pandas怎某一列特征的值将数据集分为两部分</h4><p>可以使用Pandas的boolean indexing和DataFrame的loc方法将数据集分成两部分，如下所示：</p>
<p>假设您的DataFrame名为df，您要根据名为“column_name”的列将其分为两部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用boolean indexing筛选出符合条件的行</span></span><br><span class="line">condition = df[<span class="string">"column_name"</span>] == some_value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用loc方法根据条件筛选出符合条件的行</span></span><br><span class="line">part1 = df.loc[condition]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用相反条件筛选出不符合条件的行</span></span><br><span class="line">part2 = df.loc[~condition]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，<code>some_value</code>是您要筛选的特定值。请将“column_name”替换为您要筛选的列名，并将<code>condition</code>更改为您要筛选的条件表达式。</p>
<p>使用以上代码，您将能够根据特定列的值将DataFrame分为两部分。</p>
<p>当您使用<code>df["column_name"] == some_value</code>时，会创建一个bool型的Series，其中每个元素的值都是<code>True</code>或<code>False</code>。该Series的长度与原始DataFrame的长度相同，对于符合条件的行，Series的值为<code>True</code>，而不符合条件的行的值则为<code>False</code>。这是Pandas中使用布尔索引（boolean indexing）的一个例子，用于筛选出符合条件的行。</p>
<p>接下来，使用<code>df.loc</code>方法选择所有满足条件的行。<code>df.loc</code>方法允许您根据行标签（index）和列标签（column）访问DataFrame的元素。在这种情况下，我们只需要根据<code>condition</code> Series的值选择满足条件的行。因此，使用<code>df.loc[condition]</code>将返回一个包含所有符合条件的行的新DataFrame，该DataFrame将成为我们所说的“part1”。</p>
<p>接下来，我们需要选择不符合条件的行，可以通过在<code>condition</code>前加上波浪线<code>~</code>来实现。这将对<code>condition</code> Series中的所有值进行逻辑反转。具体而言，所有为<code>True</code>的值将变为<code>False</code>，所有为<code>False</code>的值将变为<code>True</code>。因此，使用<code>df.loc[~condition]</code>将返回一个包含所有不符合条件的行的新DataFrame，该DataFrame将成为我们所说的“part2”。</p>
<p>综上所述，这些代码使用了Pandas的布尔索引和DataFrame的loc方法，以根据指定列的特定值将DataFrame分为两部分。</p>
<h4 id="hist"><a href="#hist" class="headerlink" title=".hist"></a>.hist</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_set[[<span class="string">'Age'</span>,<span class="string">'SibSp'</span>]].hist(figsize=(<span class="number">10</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>创建了一个直方图（histogram）图表，用于显示 train_set 数据集中的 “Age” 和 “SibSp” 两个变量的分布情况。其中，<code>train_set[['Age','SibSp']]</code> 表示从 <code>train_set</code> 数据集中选取名为 “Age” 和 “SibSp” 两列数据，<code>hist()</code> 方法则生成直方图，并可以通过 <code>figsize=(10,4)</code> 参数设置图表的大小。</p>
<p><img src="https://raw.githubusercontent.com/RisingAuroras/giteePagesImgs/master/202304262208128.png" alt="image-20230426220812047"></p>
<h4 id="factorize"><a href="#factorize" class="headerlink" title="factorize"></a>factorize</h4><p> 可以对特征中中的元素进行标签编码，并返回一个包含两个元素的元组，第一个元素为编码后的标签，<strong>第二个元素为对应的唯一标签列表</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame({</span><br><span class="line">    <span class="string">'color'</span>: [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'green'</span>],</span><br><span class="line">    <span class="string">'size'</span>: [<span class="string">'S'</span>, <span class="string">'M'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>, <span class="string">'S'</span>, <span class="string">'S'</span>]</span><br><span class="line">})</span><br><span class="line">labels, uniques = df[<span class="string">'color'</span>].factorize()</span><br><span class="line"><span class="built_in">print</span>(labels,uniques)<span class="comment"># [0 1 2 0 1 1] Index(['red', 'green', 'blue'], dtype='object')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果只想得到编码，可以像如下这样写</span></span><br><span class="line">encoded_labels = df[<span class="string">'color'</span>].factorize()[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(encoded_labels)<span class="comment"># [0 1 2 0 1 1]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="value-counts"><a href="#value-counts" class="headerlink" title="value_counts"></a>value_counts</h4><p>在 Pandas 中，<code>value_counts()</code> 是一种用于统计一个 Pandas 对象中每个不同值的出现次数的方法。这个方法可以用于 Series、DataFrame 或者是一个 GroupBy 对象。</p>
<p>具体来说，<code>value_counts()</code> 方法可以统计一个 Series 中每个不同的值出现的次数，并返回一个新的 Series 对象，其中包含了不同值及其出现次数的信息。这个新的 Series 对象的索引是每个不同值本身，而其对应的值则是这个值出现的次数。</p>
<p>例如，我们有如下的一个 Series 对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.Series([<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'banana'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>])</span><br><span class="line">value_counts = data.value_counts()</span><br><span class="line"><span class="built_in">print</span>(value_counts)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">apple     2</span></span><br><span class="line"><span class="string">banana    2</span></span><br><span class="line"><span class="string">orange    1</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>这里，<code>value_counts</code> 变量就是一个包含了不同值及其出现次数的 Series 对象。可以看到，其中包含了每个不同值出现的次数，例如，’apple’ 和 ‘banana’ 分别出现了 2 次，而 ‘orange’ 只出现了 1 次。</p>
<p>在 DataFrame 中，我们也可以对某一列进行统计，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame({<span class="string">'A'</span>: [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>, <span class="string">'foo'</span>], <span class="string">'B'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]})</span><br><span class="line"></span><br><span class="line">value_counts = df[<span class="string">'A'</span>].value_counts()</span><br><span class="line"><span class="built_in">print</span>(value_counts)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">foo    4</span></span><br><span class="line"><span class="string">bar    2</span></span><br><span class="line"><span class="string">Name: A, dtype: int64</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>value_counts</code> 中包含了 ‘A’ 列中每个不同值出现的次数。</p>
<h4 id="sort-index"><a href="#sort-index" class="headerlink" title="sort_index()"></a>sort_index()</h4><p>在 Pandas 中，<code>sort_index()</code> 是一种对 Pandas 对象进行排序的方法。这个方法可以用于对 Pandas 中的 Series、DataFrame 或者 GroupBy 对象按照索引进行排序。</p>
<p>具体来说，<code>sort_index()</code> 方法可以根据对象的索引进行排序，并返回一个新的排序后的对象。这个方法可以接受多个参数，用于控制排序的方式和顺序。其中，一些常用的参数包括：</p>
<ul>
<li><code>axis</code>：指定按照哪个轴进行排序。默认为 0，表示按照行索引进行排序。如果为 1，则表示按照列索引进行排序。</li>
<li><code>ascending</code>：指定是否按照升序排序。默认为 True，表示按照升序排序。如果为 False，则表示按照降序排序。</li>
<li><code>inplace</code>：指定是否在原对象上进行排序。默认为 False，表示返回一个新的排序后的对象。如果为 True，则表示在原对象上进行排序，并返回 None。</li>
</ul>
<p>例如，我们有如下的一个 Series 对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.Series([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>], index=[<span class="string">'B'</span>, <span class="string">'E'</span>, <span class="string">'A'</span>, <span class="string">'D'</span>, <span class="string">'C'</span>])</span><br><span class="line"></span><br><span class="line">sorted_data = data.sort_index()</span><br><span class="line"><span class="built_in">print</span>(sorted_data)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">A    3</span></span><br><span class="line"><span class="string">B    2</span></span><br><span class="line"><span class="string">C    4</span></span><br><span class="line"><span class="string">D    5</span></span><br><span class="line"><span class="string">E    1</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>在 DataFrame 中，我们也可以对行或列进行排序，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame({<span class="string">'B'</span>: [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>], <span class="string">'A'</span>: [<span class="string">'B'</span>, <span class="string">'E'</span>, <span class="string">'A'</span>, <span class="string">'D'</span>, <span class="string">'C'</span>]})</span><br><span class="line">df</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">	B	A</span></span><br><span class="line"><span class="string">0	2	B</span></span><br><span class="line"><span class="string">1	1	E</span></span><br><span class="line"><span class="string">2	3	A</span></span><br><span class="line"><span class="string">3	5	D</span></span><br><span class="line"><span class="string">4	4	C</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">sorted_df = df.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_df)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">   A  B</span></span><br><span class="line"><span class="string">0  B  2</span></span><br><span class="line"><span class="string">1  E  1</span></span><br><span class="line"><span class="string">2  A  3</span></span><br><span class="line"><span class="string">3  D  5</span></span><br><span class="line"><span class="string">4  C  4</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="nunique"><a href="#nunique" class="headerlink" title="nunique"></a>nunique</h4><p>在 Pandas 中，”nunique()” 是一个用于计算唯一值数量的方法，它可以用于 Pandas Series 和 DataFrame 对象。它返回序列或数据框中唯一元素的数量。</p>
<p>下面是一个简单的例子，展示了如何使用 “nunique()” 方法来计算一个 Pandas Series 对象中唯一值的数量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Pandas Series 对象</span></span><br><span class="line">s = pd.Series([<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'cat'</span>, <span class="string">'bird'</span>, <span class="string">'dog'</span>, <span class="string">'fish'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 nunique() 方法计算唯一值数量</span></span><br><span class="line">unique_count = s.nunique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印唯一值数量</span></span><br><span class="line"><span class="built_in">print</span>(unique_count)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们首先创建了一个包含多个字符串元素的 Pandas Series 对象。然后，我们使用 “nunique()” 方法计算了该序列中唯一元素的数量，结果为 4。因为序列中有四个唯一的元素：’cat’, ‘dog’, ‘bird’, 和 ‘fish’。</p>
<p>下面是一个使用 Pandas DataFrame 对象的示例，演示了如何使用 “nunique()” 方法计算每列的唯一值数量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Pandas DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame({<span class="string">'A'</span>: [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>, <span class="string">'foo'</span>],</span><br><span class="line">                   <span class="string">'B'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>],</span><br><span class="line">                   <span class="string">'C'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]})</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 nunique() 方法计算每列唯一值的数量</span></span><br><span class="line">unique_counts = df.nunique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印每列唯一值的数量</span></span><br><span class="line"><span class="built_in">print</span>(unique_counts)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">A    2</span></span><br><span class="line"><span class="string">B    2</span></span><br><span class="line"><span class="string">C    6</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们首先创建了一个包含三列数据的 Pandas DataFrame 对象。然后，我们使用 “nunique()” 方法计算了每列中唯一元素的数量，结果为 Pandas Series 对象。由于 DataFrame 中的列 “A” 和 “B” 中有两个唯一元素，而列 “C” 中有 6 个唯一元素，因此输出结果分别为 2 和 6。</p>
<h4 id="corr"><a href="#corr" class="headerlink" title="corr"></a>corr</h4><p>在 Pandas 中，<code>.corr()</code> 方法用于计算两个数据列之间的相关系数，其中 <code>method</code> 参数指定了计算相关系数所使用的方法。常见的方法包括 Pearson 相关系数和 Spearman 秩相关系数。</p>
<ul>
<li><code>corr(method='pearson')</code>: 计算两个数据列之间的 Pearson 相关系数。Pearson 相关系数是衡量两个变量之间<strong>线性关系强度</strong>和方向的一种方法，取值范围为 -1 到 1，其中 1 表示完全正相关，0 表示没有相关性，-1 表示完全负相关。Pearson 相关系数假定变量之间的关系是线性的，且变量服从正态分布。</li>
<li><code>corr(method='spearman')</code>: 计算两个数据列之间的 Spearman 秩相关系数。Spearman 相关系数是一种非参数方法，它将每个变量的值用其排名来表示，因此可以处理<strong>非线性关系和非正态分布的数据</strong>。Spearman 相关系数取值范围为 -1 到 1，其中 1 表示完全正相关，0 表示没有相关性，-1 表示完全负相关。</li>
</ul>
<p>在实际应用中，可以根据数据的特点和分析目的选择合适的相关系数计算方法。如果数据服从正态分布，且变量之间的关系是线性的，则可以使用 Pearson 相关系数。如果数据不服从正态分布，或者存在非线性关系，则应该使用 Spearman 相关系数。</p>
<h4 id="to-datetime"><a href="#to-datetime" class="headerlink" title="to_datetime()"></a>to_datetime()</h4><p><code>pd.to_datetime()</code>函数是pandas库中的一个函数，用于将输入的日期或时间字符串转换为datetime格式。</p>
<p>这个函数的作用主要有两个方面。首先，它能够将日期或时间字符串转换为Python中的datetime对象，这样我们就可以使用Python内置的datetime模块对时间数据进行操作和计算。其次，它能够将datetime对象转换为pandas中的Timestamp对象，这样我们就可以更方便地使用pandas对时间序列数据进行处理和分析。</p>
<p><code>pd.to_datetime()</code>函数有多种用法，可以接受不同格式的日期或时间字符串，也可以接受多个输入，并将它们转换为一个pandas中的DatetimeIndex或PeriodIndex。另外，这个函数还支持一些额外的参数，用于指定日期或时间字符串的格式、时区等信息。</p>
<p>好的，下面是一个例子，假设我们有一个字符串列表，其中存储了多个日期字符串，格式为’%Y-%m-%d’，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date_strings = [<span class="string">'2022-01-01'</span>, <span class="string">'2022-01-02'</span>, <span class="string">'2022-01-03'</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>pd.to_datetime()</code>函数将这些日期字符串转换为datetime格式，并将它们存储为一个pandas中的DatetimeIndex对象。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义日期字符串列表</span></span><br><span class="line">date_strings = [<span class="string">'2022-01-01'</span>, <span class="string">'2022-01-02'</span>, <span class="string">'2022-01-03'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将日期字符串转换为DatetimeIndex对象</span></span><br><span class="line">dates = pd.to_datetime(date_strings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出转换后的结果</span></span><br><span class="line"><span class="built_in">print</span>(dates)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们调用<code>pd.to_datetime()</code>函数将日期字符串列表<code>date_strings</code>中的每个日期字符串转换为datetime格式，并将它们存储为一个pandas中的DatetimeIndex对象<code>dates</code>。由于这些日期字符串的格式为’%Y-%m-%d’，因此在默认情况下，<code>pd.to_datetime()</code>函数可以正确地解析这些字符串并将它们转换为datetime格式。</p>
<p>执行以上代码后，程序将输出转换后的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatetimeIndex([<span class="string">'2022-01-01'</span>, <span class="string">'2022-01-02'</span>, <span class="string">'2022-01-03'</span>], dtype=<span class="string">'datetime64[ns]'</span>, freq=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>pd.to_datetime()</code>函数将输入的日期字符串转换为了一个DatetimeIndex对象，其中的每个元素都是一个datetime对象，表示对应的日期。</p>
<h4 id="skew"><a href="#skew" class="headerlink" title="skew"></a>skew</h4><p><code>DataFrame.skew(axis=None,skipna=None,level=None, numeric_only=None, **kwargs)</code></p>
<blockquote>
<ul>
<li>axis : {index (0), columns (1)}<br>定义计算的轴</li>
<li>skipna : boolean, default True<br>计算时是否忽略空缺值，默认忽略</li>
<li>level : int or level name, default None<br>（用的比较少）</li>
<li>numeric_only : boolean, default None<br>（用的比较少）</li>
</ul>
</blockquote>
<p>偏度（skewness），是统计数据分布偏斜方向和程度的度量，是统计数据分布非对称程度的数字特征。偏度(Skewness)亦称偏态、偏态系数。<br>表征概率分布密度曲线相对于平均值不对称程度的特征数。直观看来就是密度函数曲线尾部的相对长度。<br>定义上偏度是样本的三阶标准化矩：</p>
<script type="math/tex; mode=display">
s k e w ( X ) ==E[(\frac{X-\mu}{\sigma})^3]\tag{$1$}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'Sold Proice has a skew of '</span> \</span><br><span class="line">      + <span class="built_in">str</span>(target.skew().<span class="built_in">round</span>(decimals=<span class="number">2</span>)) \</span><br><span class="line">      + <span class="string">' while the log-transformed Sold Price improves the skew to '</span> \</span><br><span class="line">      + <span class="built_in">str</span>(np.log(target).skew().<span class="built_in">round</span>(decimals=<span class="number">2</span>)))</span><br><span class="line"><span class="comment">#Sold Proice has a skew of 12.51 while the log-transformed Sold Price improves the skew to 0.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>创建一个人工数据集，并存储在CSV（逗号分隔值）文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.makedirs(os.path.join(<span class="string">'..'</span>, <span class="string">'data'</span>), exist_ok=<span class="literal">True</span>)</span><br><span class="line">data_file = os.path.join(<span class="string">'..'</span>, <span class="string">'data'</span>, <span class="string">'house_tiny.csv'</span>)</span><br><span class="line"><span class="built_in">print</span>(data_file)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(data_file, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'NumRooms,Alley,Price\n'</span>)</span><br><span class="line">    f.write(<span class="string">'NA,Pave,127500\n'</span>)</span><br><span class="line">    f.write(<span class="string">'2,NA,106000\n'</span>)</span><br><span class="line">    f.write(<span class="string">'4,NA,178100\n'</span>)</span><br><span class="line">    f.write(<span class="string">'NA,NA,140000\n'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..\data\house_tiny.csv</span><br></pre></td></tr></table></figure>
<p>从创建的CSV文件中加载原始数据集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   NumRooms Alley   Price</span><br><span class="line">0       NaN  Pave  127500</span><br><span class="line">1       2.0   NaN  106000</span><br><span class="line">2       4.0   NaN  178100</span><br><span class="line">3       NaN   NaN  140000</span><br></pre></td></tr></table></figure>
<p>为了处理缺失的数据，典型的方法包括<em>插值法</em>和<em>删除法</em>， 这里，我们将考虑插值法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inputs, outputs = data.iloc[:, <span class="number">0</span>:<span class="number">2</span>], data.iloc[:, <span class="number">2</span>]<span class="comment"># iloc：对数据进行位置索引，从而在数据表中提取出相应的数据。</span></span><br><span class="line">inputs = inputs.fillna(inputs.mean())</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   NumRooms Alley</span><br><span class="line">0       3.0  Pave</span><br><span class="line">1       2.0   NaN</span><br><span class="line">2       4.0   NaN</span><br><span class="line">3       3.0   NaN</span><br></pre></td></tr></table></figure>
<p>对于<code>inputs</code>中的类别值或离散值，我们将“NaN”视为一个类别</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputs = pd.get_dummies(inputs, dummy_na=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   NumRooms  Alley_Pave  Alley_nan</span><br><span class="line">0       3.0           1          0</span><br><span class="line">1       2.0           0          1</span><br><span class="line">2       4.0           0          1</span><br><span class="line">3       3.0           0          1</span><br></pre></td></tr></table></figure>
<p>现在<code>inputs</code>和<code>outputs</code>中的所有条目都是数值类型，它们可以转换为张量格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">X, y = torch.tensor(inputs.values), torch.tensor(outputs.values)</span><br><span class="line">X, y</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(tensor([[3., 1., 0.],</span><br><span class="line">         [2., 0., 1.],</span><br><span class="line">         [4., 0., 1.],</span><br><span class="line">         [3., 0., 1.]], dtype=torch.float64),</span><br><span class="line"> tensor([127500, 106000, 178100, 140000]))</span><br></pre></td></tr></table></figure>
<h2 id="featuretools"><a href="#featuretools" class="headerlink" title="featuretools"></a>featuretools</h2><p>Featuretools是一个自动化的特征工程工具，它可以自动化地生成大量的特征。要控制生成的特征数量，可以使用以下方法：</p>
<p>Featuretools是一个自动化的特征工程工具，它可以自动化地生成大量的特征。要控制生成的特征数量，可以使用以下方法：</p>
<ol>
<li>max_features：可以使用Featuretools中的max_features参数来限制生成的特征数量。例如：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">features, feature_names = ft.dfs(entityset=es, target_entity=<span class="string">'customers'</span>, max_features=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p>这将限制生成的特征数量不超过50个。</p>
<ol>
<li>选择感兴趣的实体和目标：在使用Featuretools时，可以明确指定想要生成特征的实体和目标实体。通过选择较小的实体和目标实体，可以减少生成的特征数量。例如：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pythonCopy codefeatures, feature_names = ft.dfs(entityset=es, target_entity=<span class="string">'transactions'</span>, </span><br><span class="line">                                 agg_primitives=[<span class="string">'mean'</span>, <span class="string">'sum'</span>], </span><br><span class="line">                                 trans_primitives=[<span class="string">'month'</span>, <span class="string">'hour'</span>],</span><br><span class="line">                                 max_depth=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们只使用transactions实体作为目标实体，并且只使用两个聚合原语和两个变换原语，以减少生成的特征数量。</p>
<ol>
<li>特征选择：在生成的特征中，可以选择一些最相关的特征。这可以通过使用特征选择技术来实现，例如卡方检验、L1正则化等。可以使用这些技术来选择最相关的特征并且减少不必要的特征。</li>
</ol>
<p>总之，控制生成的特征数量可以通过max_features参数、选择感兴趣的实体和目标以及特征选择等方法来实现。</p>
<h2 id="程序设计思想"><a href="#程序设计思想" class="headerlink" title="程序设计思想"></a>程序设计思想</h2><h3 id="内存访问的局部性原理"><a href="#内存访问的局部性原理" class="headerlink" title="内存访问的局部性原理"></a>内存访问的局部性原理</h3><p>内存访问的局部性原理（Locality of Reference）是计算机系统设计和优化中的一个重要原则。该原理指出，程序在某个时间段 内对内存的访问往往会倾向于访问相邻的内存位置，而不是随机地访问内存。</p>
<p>局部性原理通常分为两种类型：</p>
<ol>
<li>时间局部性（Temporal Locality）：在程序中，如果一个数据项被访问，那么在不久的将来它可能再次被访问。这是因为程序中存在循环、迭代和局部变量等结构，这些结构会导致数据被多次使用。通过利用时间局部性，计算机系统可以缓存最近使用的数据项，从而提高内存访问速度。</li>
<li>空间局部性（Spatial Locality）：在程序中，如果一个数据项被访问，那么与该数据项相邻的数据项也可能被访问。这是因为程序中存在顺序执行、数组和数据结构等结构，这些结构会导致连续的数据项被访问。通过利用空间局部性，计算机系统可以预取（prefetch）相邻的数据项到高速缓存中，从而减少内存访问延迟。</li>
</ol>
<p>局部性原理的优势在于，高速缓存（Cache）和处理器的内部缓存（Registers）等快速存储设备可以通过预先加载（或保持）可能被频繁访问的数据项，从而减少内存访问的延迟。这种缓存机制提高了计算机系统的性能，并减少了对主内存的频繁访问。</p>
<p>为了充分利用局部性原理，程序设计和优化时可以采取以下策略：</p>
<ul>
<li>使用局部变量：在循环和迭代中尽量使用局部变量，避免频繁访问全局变量。</li>
<li>数据结构优化：尽量使用紧凑的数据结构，减少内存碎片和跳跃式访问。</li>
<li>循环优化：重构循环结构，使得内存访问更连续、更紧凑。</li>
<li>缓存友好的编程：将常用的数据项存储在连续的内存位置，以提高空间局部性。</li>
<li>数据预取：通过预取技术将未来可能访问的数据项加载到高速缓存中。</li>
</ul>
<p>通过遵循局部性原理，可以提高计算机程序的性能，减少内存访问的延迟，并更好地利用计算机系统的缓存层次结构。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://mr-maktoub.github.io">马克图布</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mr-maktoub.github.io/posts/8089/">https://mr-maktoub.github.io/posts/8089/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mr-maktoub.github.io" target="_blank">马克图布</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/95a0/" title="b站土堆PyTorch深度学习快速入门教程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">b站土堆PyTorch深度学习快速入门教程</div></div></a></div><div class="next-post pull-right"><a href="/posts/0/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/68cb/" title="Python标准库之argparse"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-02</div><div class="title">Python标准库之argparse</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">马克图布</div><div class="author-info__description">记录我的遗忘</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#python"><span class="toc-number">1.</span> <span class="toc-text">python</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E4%B8%8B-init-py%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">包下__init__.py的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E4%B8%AD%E7%9A%84-%E4%B8%8E-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">python中的*与**用法详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPython"><span class="toc-number">1.3.</span> <span class="toc-text">IPython</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pylab"><span class="toc-number">1.4.</span> <span class="toc-text">pylab</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#filter"><span class="toc-number">1.5.1.</span> <span class="toc-text">filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map"><span class="toc-number">1.5.2.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reduce"><span class="toc-number">1.5.3.</span> <span class="toc-text">Reduce</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84Class"><span class="toc-number">1.6.</span> <span class="toc-text">Python中的Class</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#staticmethod"><span class="toc-number">1.6.1.</span> <span class="toc-text">@staticmethod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#property"><span class="toc-number">1.6.2.</span> <span class="toc-text">@property</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getitem"><span class="toc-number">1.6.3.</span> <span class="toc-text">__getitem__</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call"><span class="toc-number">1.6.4.</span> <span class="toc-text">__call__</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda"><span class="toc-number">1.7.</span> <span class="toc-text">lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.8.</span> <span class="toc-text">类型注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.8.1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93-typing-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E6%A0%87%E6%B3%A8"><span class="toc-number">1.8.2.</span> <span class="toc-text">标准库 typing 类型注解标注</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABC"><span class="toc-number">1.9.</span> <span class="toc-text">ABC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#itertools"><span class="toc-number">1.10.</span> <span class="toc-text">itertools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice"><span class="toc-number">1.11.</span> <span class="toc-text">slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zip"><span class="toc-number">1.12.</span> <span class="toc-text">zip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collection"><span class="toc-number">1.13.</span> <span class="toc-text">collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="toc-number">1.14.</span> <span class="toc-text">排序方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#numpy"><span class="toc-number">2.</span> <span class="toc-text">numpy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#axis"><span class="toc-number">2.1.</span> <span class="toc-text">axis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#save-amp-load"><span class="toc-number">2.2.</span> <span class="toc-text">save &amp; load</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#squeeze-%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">squeeze()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#median"><span class="toc-number">2.4.</span> <span class="toc-text">median()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#expand-dims"><span class="toc-number">2.5.</span> <span class="toc-text">expand_dims()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#np-linalg"><span class="toc-number">2.6.</span> <span class="toc-text">np.linalg</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#np-linalg-norm"><span class="toc-number">2.6.1.</span> <span class="toc-text">np.linalg.norm</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#random"><span class="toc-number">2.7.</span> <span class="toc-text">random</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#random-1"><span class="toc-number">2.7.1.</span> <span class="toc-text">random()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#random-sample"><span class="toc-number">2.7.2.</span> <span class="toc-text">random_sample()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rand-d0-d1%E2%80%A6dn"><span class="toc-number">2.7.3.</span> <span class="toc-text">&#96;rand(d0,d1…dn)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#randn"><span class="toc-number">2.7.4.</span> <span class="toc-text">randn()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#numpy-random-randint-low-high-None-size-None-dtype-%E2%80%99l%E2%80%99"><span class="toc-number">2.7.5.</span> <span class="toc-text">numpy.random.randint(low, high&#x3D;None, size&#x3D;None, dtype&#x3D;’l’)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#np-random-normal-mu-sigma-size"><span class="toc-number">2.7.6.</span> <span class="toc-text">np.random.normal(mu, sigma, size)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#choice-a-size-None-replace-True-p-None"><span class="toc-number">2.7.7.</span> <span class="toc-text">choice(a, size&#x3D;None, replace&#x3D;True, p&#x3D;None)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shuffle-x"><span class="toc-number">2.7.8.</span> <span class="toc-text">shuffle(x)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#default-rng-myseed"><span class="toc-number">2.7.9.</span> <span class="toc-text">default_rng(myseed)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tile"><span class="toc-number">2.8.</span> <span class="toc-text">tile()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std"><span class="toc-number">2.9.</span> <span class="toc-text">std()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%EF%BC%88broadcasting%EF%BC%89"><span class="toc-number">2.10.</span> <span class="toc-text">广播（broadcasting）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#np-power-x1-x2"><span class="toc-number">2.11.</span> <span class="toc-text">np.power(x1,x2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#numpy-where%E2%80%94%E5%B0%86%E6%9D%A1%E4%BB%B6%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BF%B0%E4%B8%BA%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97"><span class="toc-number">2.12.</span> <span class="toc-text">numpy.where—将条件逻辑表述为数组运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#np-mgrid-np-ravel-np-c"><span class="toc-number">2.13.</span> <span class="toc-text">np.mgrid[] np.ravel np.c_[]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#np-fromstring"><span class="toc-number">2.14.</span> <span class="toc-text">np.fromstring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#np-vstack"><span class="toc-number">2.15.</span> <span class="toc-text">np.vstack()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#np-hstack"><span class="toc-number">2.16.</span> <span class="toc-text">np.hstack()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#np-argsort"><span class="toc-number">2.17.</span> <span class="toc-text">np.argsort()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#numpy%E4%B9%8Bdtype%E3%80%81type%E4%BB%A5%E5%8F%8Aastype%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">2.18.</span> <span class="toc-text">numpy之dtype、type以及astype的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#savetxt"><span class="toc-number">2.19.</span> <span class="toc-text">savetxt()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-printoptions-suppress-True"><span class="toc-number">2.20.</span> <span class="toc-text">set_printoptions(suppress&#x3D;True)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concatenate"><span class="toc-number">2.21.</span> <span class="toc-text">concatenate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reshape"><span class="toc-number">2.22.</span> <span class="toc-text">reshape</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#matplotlib"><span class="toc-number">3.</span> <span class="toc-text">matplotlib</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Seaborn"><span class="toc-number">4.</span> <span class="toc-text">Seaborn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tensorflow"><span class="toc-number">5.</span> <span class="toc-text">tensorflow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tensor%E5%88%9B%E5%BB%BA"><span class="toc-number">5.1.</span> <span class="toc-text">tensor创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">常用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tensorflow-probability"><span class="toc-number">5.3.</span> <span class="toc-text">tensorflow_probability</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sklearn"><span class="toc-number">6.</span> <span class="toc-text">sklearn</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sklearn%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88Pipeline%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">sklearn流水线（Pipeline）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sklearn%E4%B8%ADRBFSampler%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">sklearn中RBFSampler的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#model-selection"><span class="toc-number">6.3.</span> <span class="toc-text">model_selection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#train-test-split"><span class="toc-number">6.3.1.</span> <span class="toc-text">train_test_split</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pytorch"><span class="toc-number">7.</span> <span class="toc-text">pytorch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#torch-utils"><span class="toc-number">7.1.</span> <span class="toc-text">torch.utils</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#data"><span class="toc-number">7.1.1.</span> <span class="toc-text">data</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TensorDataset"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">TensorDataset</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#torch-nn"><span class="toc-number">7.2.</span> <span class="toc-text">torch.nn</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#functional"><span class="toc-number">7.2.1.</span> <span class="toc-text">functional</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#one-hot"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">one_hot</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AdaptiveAvgPool2d"><span class="toc-number">7.2.2.</span> <span class="toc-text">AdaptiveAvgPool2d</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConvTranspose2d"><span class="toc-number">7.2.3.</span> <span class="toc-text">ConvTranspose2d</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#torchvision"><span class="toc-number">7.3.</span> <span class="toc-text">torchvision</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#models"><span class="toc-number">7.3.1.</span> <span class="toc-text">models</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transforms-ToTensor"><span class="toc-number">7.3.2.</span> <span class="toc-text">transforms.ToTensor()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#torch-distributions"><span class="toc-number">7.4.</span> <span class="toc-text">torch.distributions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#torch-distributions-categorical-probs"><span class="toc-number">7.4.1.</span> <span class="toc-text">torch.distributions.categorical(probs)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#torch-distributions-normal-Normal"><span class="toc-number">7.4.2.</span> <span class="toc-text">torch.distributions.normal.Normal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#torch-as-tensor"><span class="toc-number">7.5.</span> <span class="toc-text">torch.as_tensor()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count-vars-module"><span class="toc-number">7.6.</span> <span class="toc-text">count_vars(module):</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#permute"><span class="toc-number">7.7.</span> <span class="toc-text">permute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-printoptions"><span class="toc-number">7.8.</span> <span class="toc-text">set_printoptions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#torch-cat"><span class="toc-number">7.9.</span> <span class="toc-text">torch.cat</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pandas"><span class="toc-number">8.</span> <span class="toc-text">pandas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">8.1.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iloc-amp-loc"><span class="toc-number">8.1.1.</span> <span class="toc-text">iloc&amp;loc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#drop"><span class="toc-number">8.1.2.</span> <span class="toc-text">drop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fillna"><span class="toc-number">8.1.3.</span> <span class="toc-text">fillna</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-dummies"><span class="toc-number">8.1.4.</span> <span class="toc-text">get_dummies</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#to-numeric"><span class="toc-number">8.1.5.</span> <span class="toc-text">to_numeric</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select-dtypes"><span class="toc-number">8.1.6.</span> <span class="toc-text">select_dtypes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dtypes"><span class="toc-number">8.1.7.</span> <span class="toc-text">dtypes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#groupby"><span class="toc-number">8.1.8.</span> <span class="toc-text">groupby</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pandas%E6%80%8E%E6%9F%90%E4%B8%80%E5%88%97%E7%89%B9%E5%BE%81%E7%9A%84%E5%80%BC%E5%B0%86%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%86%E4%B8%BA%E4%B8%A4%E9%83%A8%E5%88%86"><span class="toc-number">8.1.9.</span> <span class="toc-text">pandas怎某一列特征的值将数据集分为两部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hist"><span class="toc-number">8.1.10.</span> <span class="toc-text">.hist</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#factorize"><span class="toc-number">8.1.11.</span> <span class="toc-text">factorize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#value-counts"><span class="toc-number">8.1.12.</span> <span class="toc-text">value_counts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-index"><span class="toc-number">8.1.13.</span> <span class="toc-text">sort_index()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nunique"><span class="toc-number">8.1.14.</span> <span class="toc-text">nunique</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#corr"><span class="toc-number">8.1.15.</span> <span class="toc-text">corr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#to-datetime"><span class="toc-number">8.1.16.</span> <span class="toc-text">to_datetime()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#skew"><span class="toc-number">8.1.17.</span> <span class="toc-text">skew</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">数据预处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#featuretools"><span class="toc-number">9.</span> <span class="toc-text">featuretools</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">10.</span> <span class="toc-text">程序设计思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">10.1.</span> <span class="toc-text">内存访问的局部性原理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3eeb/" title="Hello World">Hello World</a><time datetime="2023-06-01T07:29:35.968Z" title="发表于 2023-06-01 15:29:35">2023-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/6f25/" title="我的云音乐APP开发课程笔记">我的云音乐APP开发课程笔记</a><time datetime="2023-06-01T07:29:35.962Z" title="发表于 2023-06-01 15:29:35">2023-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8462/" title="重新梳理Android权限管理">重新梳理Android权限管理</a><time datetime="2023-06-01T07:29:35.959Z" title="发表于 2023-06-01 15:29:35">2023-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/9958/" title="《吴恩达机器学习笔记》">《吴恩达机器学习笔记》</a><time datetime="2023-06-01T07:29:35.949Z" title="发表于 2023-06-01 15:29:35">2023-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/935d/" title="常见不等式、等式与基础理论">常见不等式、等式与基础理论</a><time datetime="2023-06-01T07:29:35.914Z" title="发表于 2023-06-01 15:29:35">2023-06-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 马克图布</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>